[{"categories":null,"content":"Je suis architecte logiciel généraliste et algorithmicien curieux.\nDe l’idée à la ligne de code, les choix sont innombrables et de natures variées.\nDistinguer ceux qui importent et les qualifier efficacement est aussi déterminant que l’expertise technique.\nToujours motivé par la recherche de la solution la plus pertinente dans des contextes des plus communs aux plus complexes, contactez-moi pour me parler de vos projets :\n par email pitt@pittscraft.com par téléphone (ou Signal, Whatsapp, Telegram) au +33 (0)6 62 98 24 38  Pierre Mardon (Pitt)\n","description":"","tags":null,"title":"À propos","uri":"/about/"},{"categories":["Application mobile"],"content":"J’avais déjà croisé un exemple d’implémentation de property wrapper et devant leur simplicité, je m’étais mis en tête de créer un property wrapper accélérant le stockage de valeurs dans les UserDefaults.\nIl se trouve que dans mes expérimentations autour de Combine j’avais bien envie de créer un wrapper publiant les nouvelles valeurs seulement après les avoirs stockées (voir ici).\nEt puis j’ai finalement voulu faire tout en même temps !\nQu’est-ce donc qu’un property wrapper ? Un property wrapper très simple s’écrit de cette manière :\n@propertyWrapper public class Print\u003cValue\u003e {ss private var val: Value public init(wrappedValue value: Value) { val = value } public var wrappedValue: Value { set { print(\"Setting '\\(val)'\") val = newValue } get { print(\"Returning '\\(val)'\") return val } } } et s’utilise ensuite ainsi :\nclass SomeClass { @Print var myString: String = \"Coucou copaing !\" func doThings() { myString = \"Bye friend\" var something = myString } } SomeClass().doThings() ce qui imprimera\n\u003e Setting 'Bye friend' \u003e Getting 'Bye friend' ce qui est plutôt nul.\nCeci-dit, si on décidait de faire des choses plus intéressantes que des print, on pourrait bien se faciliter la vie !\nGot UserDefaults ? Stocker des propriétés dans les UserDefaults Voilà un usage fréquent et intéressant.\n@propertyWrapper public struct UserDefaultsBacked\u003cValue\u003e { private let key: String private let defaultValue: Value private let storage: UserDefaults public init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard) { defaultValue = value self.key = key self.storage = storage } public var wrappedValue: Value { get { storage.value(forKey: key) as? Value ?? defaultValue} set { storage.setValue(newValue, forKey: key) } } } Et une implémentation un peu naïve comme celle ci-dessus peut faire l’affaire.\nUn petit warning quand même, on n’oublie pas que chaque setValue sur une clé de UserDefaults réécrit le dictionnaire complet. On utilisera donc tout ça en connaissance de cause, et n’oublions pas qu’on peut aussi réduire leur taille en n’utilisant pas systématiquement le .standard.\nOn peut noter la présence de nouveaux arguments du constructeur, la key et le storage. Ils peuvent être fournis via la déclaration de l’annotation, ou doivent l’être pour ceux qui n’ont pas de valeur par défaut comme la key.\n@UserDefaultsBacked(\"int-key\") // Smells like Java var someInt = 8 @UserDefaultsBacked(\"my-data\", storage: UserDefaults(\"DBName\")) var someData: Data? = nil struct SomeStruct { var prop = \"Yup\" } @UserDefaultsBacked(\"my-struct\") var myStruct = SomeStruct() // Wait... What ? Stocker uniquement les types compatibles Ce wrapper fonctionnera très bien avec tous les types supportés par les UserDefaults mais attendez-vous à de bons crashes pour tous les autres cas, comme SomeStruct.\nRestreignons-donc déjà l’usage aux bonnes valeurs grâce à un flag protocol :\npublic protocol UserDefaultsStorable {} extension String : UserDefaultsStorable {} extension Int: UserDefaultsStorable {} extension Double: UserDefaultsStorable {} extension Float: UserDefaultsStorable {} extension Date: UserDefaultsStorable {} extension Data: UserDefaultsStorable {} extension Array: UserDefaultsStorable where Element: UserDefaultsStorable {} extension Dictionary: UserDefaultsStorable where Key == String, Value: UserDefaultsStorable {} @propertyWrapper public struct UserDefaultsBacked\u003cValue\u003e { private let key: String private let defaultValue: Value private let storage: UserDefaults public init(wrappedValue value: Value, key: String, storage: UserDefaults = .standard) where Value: UserDefaultsStorable { defaultValue = value self.key = key self.storage = storage } public var wrappedValue: Value { get { storage.value(forKey: key) as? Value ?? defaultValue} set { storage.setValue(newValue, forKey: key) } } } Ok, on a maintenant un property wrapper sélectif et une belle erreur de compilation dans le cas où le type ne se conforme pas à UserDefaultsStorable.\n@UserDefaultsBacked(\"my-struct\") var myStruct = SomeStruct() // Error: Initializer 'init(wrappedValue:_:storage)' requires that 'SomeStruct' conform to 'UserDefaultsStorable' Stocker les Codables Bien mais SomeStruct n’est pas bien mystérieux, ce serait bien sympa de pouvoir le stocker aussi. En fait, tout codable est a priori stockable puisque Data l’est. Seulement pour éviter de se faire la conversion à chaque accès, profitons donc de notre wrapper.\nGénéralisons : on peut avoir à mapper les données dans un sens et dans l’autre pour pouvoir les stocker. L’interface de UserDefaults utilise le très générique Any?, on va donc définir les mappers :\ntypealias StoringMapper\u003cValue\u003e = (Value) -\u003e Any? typealias StoreReadingMapper\u003cValue\u003e = (Any?) -\u003e Value? Puis:\n définir des propriétés de ce type dans notre wrapper. définir un constructeur privé aveugle qui prend de bonne fois n’importe quel type de propriété avec des mappers définir des constructeurs publics stricts sur le type qui vont fournir des mappers au constructeur privé  @propertyWrapper public class UserDefaultsBacked\u003cValue\u003e { private let key: String private let storage: UserDefaults private let defaultValue: Value private var storingMapper: (Value) -\u003e Any? private var storeReadingMapper: (Any?) -\u003e Value? private init(wrappedValue value: Value, _ key: String , storage: UserDefaults, storingMapper: @escaping StoringMapper\u003cValue\u003e, storeReadingMapper: @escaping StoreReadingMapper\u003cValue\u003e) { var initValue = value if let storedValue = storeReadingMapper(storage.object(forKey: key)) { initValue = storedValue } defaultValue = initValue self.key = key self.storage = storage self.storingMapper = storingMapper self.storeReadingMapper = storeReadingMapper } public convenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value: UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, storingMapper: {$0}, storeReadingMapper: { $0 as? Value}) } public var wrappedValue: Value { get { storage.value(forKey: key) as? Value ?? defaultValue} set { storage.setValue(newValue, forKey: key) } } } Mais pour mes Codables les mappers ne sont pas si évidents.\npublic extension Encodable { func mapForStorage() -\u003e Any? { do { return try JSONEncoder().encode(self) } catch { print(\"Couldn't encode \\(self)\", error) return nil } } } Ci-dessus la fonction d’encodage, avec absolument pas de check sur le cas où l’objet est également stockable nativement, car la discrimination s’effectuera en amont. Bon, c’est l’équivalent de try? JSONEncoder().encode(self) mais avec une trace pour ne pas être complètement dans le brouillard en cas de problème. Evidemment on préfèrera certainement donner de meilleures options de traçage, et certains se sentent mal (à raison) de ne pas throw quoi que ce soit, mais ce n’est pas le débat ici. Et puis comme on dit parfois : “Quand tout va bien, tout va bien !”.\n/// Simple type opening using a static function to allow JSON decoding with erased types conforming to `Decodable` protocol fileprivate extension Decodable { static func openedJSONDecode(using decoder: JSONDecoder, from data: Data) throws -\u003e Self { return try decoder.decode(self, from: data) } } Joyeusement pompé de ce post SO\nTiens je parlais dans mon poste précédent de type erasure, mais saviez vous que l’inverse est le type opening ? Eh bien pareil, je me suis couché moins bête. Et pour tous ceux qui ont déjà joué avec un JSONDecoder dans des contextes génériques un peu poussés, la feinte ci-dessus est plutôt cool à retenir : une fonction statique a toujours accès au type concret, ce qui satisfait le compilo.\npublic extension Decodable { static func mapOutOfStorage(_ value: Any?) -\u003e Self? { guard let data = value as? Data else { return nil } do { return try Self.openedJSONDecode(using: JSONDecoder(), from: data) } catch { print(\"Couldn't decode \\(String(describing: value))\", error) // Very opinionated choice to ignore thrown errors return nil } } } Et voilà, sur tout type se conformant à Decodable on a désormais cette fonction mapOutOfStorage.\nJe rappelle que typealias Codable = Decodable \u0026 Encodable, donc pour tout type Codable on a nos deux mappers \\o/\nRajoutons donc ce petit constructeur à notre property wrapper UserDefaultsBacked :\nconvenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard) where Value : Codable { self.init(wrappedValue: value, key, storage: storage, storingMapper: Value.mapForStorage, storeReadingMapper: Value.mapOutOfStorage) } Nice, et maintenant qu’est ce qui se passe si je déclare quelque chose comme :\n@UserDefaultsBacked(\"myKey\") var myInt = 0 // Error: Ambiguous use of 'init(wrappedValue:_:storage:sendAfterStore:)' Eh bien les Int étant Codable mais aussi UserDefaultsStorable, le compilateur ne saura quel constructeur choisir. Deux solutions : enlever l’ambiguité en changeant la signature d’un des constructeurs (ce qui est un peu minable, même simplement d’y avoir pensé), ou donner un constructeur qui match encore mieux, avec where Value : Codable \u0026 UserDefaultsStorable. Encore un bon trick, vous êtes bienvenus.\nCheckpoint Voici un petit bilan :\n/// Any type implementing this protocol can be stored natively in UserDefaults public protocol UserDefaultsStorable {} /** Declare proper flag protocol conformance for all types natively compatible with UserDefaults storage */ extension String : UserDefaultsStorable {} extension Int: UserDefaultsStorable {} extension Double: UserDefaultsStorable {} extension Float: UserDefaultsStorable {} extension Date: UserDefaultsStorable {} extension Data: UserDefaultsStorable {} extension Array: UserDefaultsStorable where Element: UserDefaultsStorable {} extension Dictionary: UserDefaultsStorable where Key == String, Value: UserDefaultsStorable {} /// `Encodable` mapping for storage public extension Encodable { func mapForStorage() -\u003e Any? { do { return try JSONEncoder().encode(self) } catch { print(\"Couldn't encode \\(self)\", error) return nil } } } /// Simple type opening using a static function to allow JSON decoding with erased types conforming to `Decodable` protocol fileprivate extension Decodable { // Useful trick from https://stackoverflow.com/questions/54963038/codable-conformance-with-erased-types static func openedJSONDecode(using decoder: JSONDecoder, from data: Data) throws -\u003e Self { return try decoder.decode(self, from: data) } } /// `Decodable` mapping for reading from storage public extension Decodable { static func mapOutOfStorage(_ value: Any?) -\u003e Self? { guard let data = value as? Data else { return nil } do { return try Self.openedJSONDecode(using: JSONDecoder(), from: data) } catch { print(\"Couldn't decode \\(String(describing: value))\", error) // Very opinionated choice to almost ignore thrown errors return nil } } } @propertyWrapper public class UserDefaultsBacked\u003cValue\u003e { private let key: String private let storage: UserDefaults private let defaultValue: Value private var storingMapper: (Value) -\u003e Any? private var storeReadingMapper: (Any?) -\u003e Value? private init(wrappedValue value: Value, _ key: String, storage: UserDefaults, storingMapper: @escaping StoringMapper\u003cValue\u003e, storeReadingMapper: @escaping StoreReadingMapper\u003cValue\u003e) { defaultValue = value self.key = key self.storage = storage self.storingMapper = storingMapper self.storeReadingMapper = storeReadingMapper } public convenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard) where Value: UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, storingMapper: {$0}, storeReadingMapper: { $0 as? Value}) } public convenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value : Codable { self.init(wrappedValue: value, key, storage: storage, storingMapper: Value.mapForStorage, storeReadingMapper: Value.mapOutOfStorage) } public convenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value : Codable \u0026 UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, storingMapper: {$0}, storeReadingMapper: {$0 as? Value}) } public var wrappedValue: Value { get { storage.value(forKey: key) as? Value ?? defaultValue} set { storage.setValue(newValue, forKey: key) } } } Fun fact : j’ai retrouvé le même flag protocol sur un post (je l’ai plus sous la main là), puis vu des implémentations proches pour les Codable, mais tout ça bien sûr après avoir réinventé la roue. Et même si on dit souvent ça péjorativement, dans une démarche d’apprentissage ça a tout son sens de regarder les solutions seulement ensuite. Et en plus c’était vachement moins bien fait, genre là pas de type checking, aucune cohabitation entre les Codable et les types natifs… Nan mais jvous jure…\nEt puis de toute façon je voulais aussi m’occuper de faire …\nUn publisher un peu custom Lorsqu’on utilise SwiftUI et Combine simplement, on va naturellement devoir taper des expression comme $myState ou $myObject.prop. Une fois passée mon aversion forte pour le PHP, j’ai creusé rapidement pour constater que ce n’était qu’une syntaxe un peu flippante pour accéder à la valeur projetée d’une wrapped property.\nProjected value ? En bref, n’importe quel property wrapper peut déclarer une var projectedValue: SomeType {...} dont le type n’est pas nécessairement le même que celui de sa wrappedValue. Et cette projectedValue est accessible grâce au dollar américain (comme tellement de choses).\n@propertyWrapper public class Print\u003cValue\u003e { private var val: Value public init(wrappedValue value: Value) { val = value } public var wrappedValue: Value { set { print(\"Setting '\\(val)'\") val = newValue } get { print(\"Returning '\\(val)'\") return val } } public var projectedValue: Int { print(\"42\") return 8 } } @Print var myString: String = \"5\" myString = \"40\" print(\"Coucou \\($myString)\") printera donc\n\u003e Setting '40' \u003e 42 \u003e Coucou 8 Aaah, je pense que j’ai fait le pire exemple qui soit, “service !” comme on dit dans l’est.\nBref, ce $ n’a en théorie pas forcément grand chose à voir avec Combine excepté qu’on l’y utilise en permanence.\nQuelques notions de Combine Typiquement, le property wrapper Published a pour type projeté la struct Published\u003cValue\u003e.Publisher (doc) qui respecte notamment le protocole Publisher (et bien plus, doc), et peut donc envoyer des Value à des Subscriber.\nDonc quand j’accède à un @Published var myString: String via $myString j’obtiens en gros une propriété dont je peux écouter les valeurs successives.\nEt quand je fais du SwiftUI ainsi : .sheet(isPresented: $vm.router.showSheet, ...), je passe donc un Publisher à la fonction sheet qui se fera un plaisir d’écouter si on doit où non présenter cette sheet.\nRappel : lorsqu’on utilise sink pour écouter les valeurs d’une var @Published via son Publisher, on reçoit la nouvelle valeur alors que la wrappedValue est encore l’ancienne valeur. Et je voudrais contourner ça dans certains cas (voir mon post précédent).\nMaintenant, ce qui m’intéresserait ce serait d’avoir ça, un Publisher que je pourrais contrôler finement pour lui envoyer des valeurs. Eh bien Combine nous fournit gracieusement le protocole Subject qui hérite de Publisher et qui présente de surcroit une fonction send(_:) permettant d’envoyer des valeurs à publier. Ses implémentations sont :\n CurrentValueSubject qui détient une valeur courante PassthroughSubject qui au contraire ne retient rien  On devrait s’en sortir avec ça !\nDidSet Publisher property wrapper Pour reproduire le comportement de @Published on pourrait écrire comme ça comme ça.\n@propertyWrapper public class BasicPublished\u003cValue\u003e { private let subject: CurrentValueSubject\u003cValue, Never\u003e public init(wrappedValue value: Value) { subject = CurrentValueSubject(value) wrappedValue = value } public var wrappedValue: Value { set { subject.send(newValue) } get { subject.value } } public var projectedValue: CurrentValueSubject\u003cValue, Never\u003e { get { subject } } } Le problème étant que lorsque le send va provoquer l’exécution de toutes les closures des subscribers, subject.value aura toujours l’ancienne valeur.\nAssez simple du coup d’y remédier :\n@propertyWrapper public class DidSetPublished\u003cValue\u003e { private var val: Value private let subject: CurrentValueSubject\u003cValue, Never\u003e public init(wrappedValue value: Value) { val = value subject = CurrentValueSubject(value) wrappedValue = value } public var wrappedValue: Value { set { val = newValue subject.send(val) } get { subject.value } } public var projectedValue: CurrentValueSubject\u003cValue, Never\u003e { get { subject } } } (je crois que cette implémentation vient de là, et je crois aussi qu’il serait plus pertinent d’utiliser PassthroughSubject a priori)\nTout ensemble Vous le saviez, mon but ultime était ~la conquête de la Suède en lama~ de combiner tout ça. Pas juste pour le fun, mais parce que dans mon archi, à un moment, j’avais besoin d’une propriété Codable (un enum) stockée dans les UserDefaults et qui ne publierait son changement de valeur qu’après l’avoir affecté à sa wrappedValue.\nEt puis d’autres besoins avec des variations : pas de stockage mais publication après affectation, stockage natif mais publication avant affectation…\nJ’aurais bien pu contourner tout ça, ou encore essayer de faire fonctionner des wrappers imbriqués, mais je voulais me frotter à cette implémentation spécifique.\nEt voilà, je vous colle juste l’ensemble là dessous, chaque détail étant expliqué dans les parties précédente (enfin faut savoir quelques trucs en amont quand même, oui).\nN’oubliez pas que la perf n’est pas l’objectif de ce wrapper (du tout).\nJe vous suggère d’ailleurs de jeter un oeil à l’implémentation de Published chez OpenCombine, qui est particulièrement élégante (ya un enum \u003c3).\n// // SmartPublished.swift // attestation // // Created by Pierre Mardon on 01/01/1970. Trust me. // import Foundation import Combine /// We need functions to map values before storing them to user defaults fileprivate typealias StoringMapper\u003cValue\u003e = (Value) -\u003e Any? /// We need functions to map values read from user defaults storage to an expected type fileprivate typealias StoreReadingMapper\u003cValue\u003e = (Any?) -\u003e Value? /// Any type implementing this protocol can be stored natively in UserDefaults public protocol UserDefaultsStorable {} /** Declare proper flag protocol conformance for all types natively compatible with UserDefaults storage */ extension String : UserDefaultsStorable {} extension Int: UserDefaultsStorable {} extension Double: UserDefaultsStorable {} extension Float: UserDefaultsStorable {} extension Date: UserDefaultsStorable {} extension Data: UserDefaultsStorable {} extension Array: UserDefaultsStorable where Element: UserDefaultsStorable {} extension Dictionary: UserDefaultsStorable where Key == String, Value: UserDefaultsStorable {} /// `Encodable` mapping for storage public extension Encodable { func mapForStorage() -\u003e Any? { do { return try JSONEncoder().encode(self) } catch { print(\"Couldn't encode \\(self)\", error) return nil } } } /// Simple type opening using a static function to allow JSON decoding with erased types conforming to `Decodable` protocol fileprivate extension Decodable { // Useful trick from https://stackoverflow.com/questions/54963038/codable-conformance-with-erased-types static func openedJSONDecode(using decoder: JSONDecoder, from data: Data) throws -\u003e Self { return try decoder.decode(self, from: data) } } /// `Decodable` mapping for reading from storage public extension Decodable { static func mapOutOfStorage(_ value: Any?) -\u003e Self? { guard let data = value as? Data else { return nil } do { return try Self.openedJSONDecode(using: JSONDecoder(), from: data) } catch { print(\"Couldn't decode \\(String(describing: value))\", error) // Very opinionated choice to almost ignore thrown errors return nil } } } /** Property wrapper that provides some common use cases options. Do NOT use for heavy performance demanding components. - `UserDefaults` storage is activated when a `key` is provided for all natively handled types and `Codable` ones - option `sendAfterStore` makes the subject send the value only after it has effectively been affected to the property itself: WARNING this is not recommended for UI bindings. Disabled by default. Usage: \\``` @SmartPublished(\"someKey\") var myProp = \"Bonjoir !\" \\``` The string property will be backed in UserDefaults.standard for the key \"someKey\". It will be effectively stored only if the value of the var is affected after its initialization, until then UserDefaults entry will stay untouched. The initial value of the property will be `\"Bonjoir !\"` if there's not value in the store. \\``` @SmartPublished(\"myCodableValueUserDefaultsKey\") var myProp = someValueOfCodableType \\``` The codables are stored the same way except they are JSON encoded if they're not natively handled by UserDefaults. \\``` @SmartPublished(sendAfterStore = true) var myProp = 8 $myProp.sink { print(\"property: \\(myProp), received: \\($0)\") } myProp = 1 \\``` Will print `property: 1, received: 1`, while with `@Published` or `sendAfterStore = false` it would be `property: 8, received: 1`. It is not recommended to use this `sendAfterStore = true` for UI-bound properties. \\``` @SmartPublished \\``` Why would you do that, just use `@Published` then! */ @propertyWrapper public class SmartPublished\u003cValue\u003e { private let key: String? private let storage: UserDefaults private let sendAfterStore: Bool private let subject: CurrentValueSubject\u003cValue, Never\u003e private var val: Value private var storingMapper: (Value) -\u003e Any? private var storeReadingMapper: (Any?) -\u003e Value? private init(wrappedValue value: Value, _ key: String? , storage: UserDefaults, sendAfterStore: Bool, storingMapper: @escaping StoringMapper\u003cValue\u003e, storeReadingMapper: @escaping StoreReadingMapper\u003cValue\u003e) { var initValue = value if let key = key, let storedValue = storeReadingMapper(storage.object(forKey: key)) { initValue = storedValue } val = initValue subject = CurrentValueSubject(initValue) self.key = key self.storage = storage self.sendAfterStore = sendAfterStore self.storingMapper = storingMapper self.storeReadingMapper = storeReadingMapper subject.send(val) } public convenience init(wrappedValue value: Value, _ key: String? = nil, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value: UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, sendAfterStore: sendAfterStore, storingMapper: {$0}, storeReadingMapper: { $0 as? Value}) } public convenience init(wrappedValue value: Value, _ key: String?, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value : Codable { self.init(wrappedValue: value, key, storage: storage, sendAfterStore: sendAfterStore, storingMapper: {$0.mapForStorage()}, storeReadingMapper: Value.mapOutOfStorage) } public convenience init(wrappedValue value: Value, _ key: String?, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value : Codable \u0026 UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, sendAfterStore: sendAfterStore, storingMapper: {$0}, storeReadingMapper: { $0 as? Value}) } public convenience init(wrappedValue value: Value, sendAfterStore: Bool = false) { self.init(wrappedValue: value, nil, storage: .standard, sendAfterStore: sendAfterStore, storingMapper: {$0}, storeReadingMapper: {$0 as? Value}) } public var wrappedValue: Value { set { if sendAfterStore { subject.send(newValue) } if let key = self.key { storage.setValue(storingMapper(newValue), forKey: key) } else { val = newValue } if !sendAfterStore { subject.send(newValue) } } get { if let key = self.key { return storeReadingMapper(storage.value(forKey: key)) ?? val } return val } } public var projectedValue: CurrentValueSubject\u003cValue, Never\u003e { get { subject } } } N’hésitez pas à me contacter pour toute remarque, insulte ou éloge, mon email est dans le footer ;)\n","description":"","tags":["iOS","Combine","SwiftUI"],"title":"SwiftUI \u0026 Combine Feedback #2 : property wrapper pour UserDefaults et @Published","uri":"/posts/swiftui_combine2/"},{"categories":["Application mobile"],"content":"Après mon premier petit TP autour de SwiftUI et Combine pour générer mes attestations de déplacement ~à la barbe de la maréchaussée~ à la volée voire en retard, j’ai profité de l’adaptation au second format d’attestation pour faire des explorations un peu plus poussées de mon architecture autour de Combine.\nJ’en sors une petite liste de considérations techniques que j’espère d’intérêt, et voici les premières !\nArchitecture: MVVM+ Pour une petite app comme celle-ci, je m’autorise des entorses à nombre de principes stricts overkill que je n’estime pas pertinents ici, avec des gains principalement en concision et lisibilité. Le MVVM est tout à fait indiqué pour un cloisonnement minimal, et en l’occurence ça ressemblait à ça\nAvec des injection par construction et donc cette instanciation initiale :\nlet store = Store(context: moContext) let model = MainViewModel(store: store, router: Router()) return MainView(model: model) On peut remarquer le petit Router qui s’est avéré fort utile pour éviter trop de plomberie. Son rôle est juste de publier des propriétés destinées à contrôler et rendre compte de la navigation. Il ne fait donc clairement pas partie du modèle ni des vues, et j’ai du mal à le considérer comme un modèle de vue étant donnée sa nature transverse.\nTant qu’il ne dépasse pas ce rôle de navigation, ne stocke qu’un minimum de données transitoires au besoin (immuables de préférence, la struct d’une personne à éditer par exemple), ça reste très lisible et on évite les chaînages de @Published orthodoxes.\nenum ActiveSheet { case attestationPresentation(person: PersonStruct), addPerson, edit(person: PersonStruct) } enum ActiveAlert { case confirmAttestation, detail(reason: Reason) } class Router: ObservableObject { @Published var showSheet = false @Published var showAlert = false private(set) var activeSheet = ActiveSheet.addPerson private(set) var activeAlert = ActiveAlert.confirmAttestation func showAttestationCreationAlert() { activeAlert = .confirmAttestation showAlert = true } func startAddPerson() { activeSheet = .addPerson showSheet = true } func startEdit(person: PersonStruct) { activeSheet = .edit(person: person) showSheet = true } func showReasonDetail(_ reason: Reason) { activeAlert = .detail(reason: reason) showAlert = true } func showAttestationView(person: PersonStruct) { activeSheet = .attestationPresentation(person: person) showSheet = true } func closeSheet() { showSheet = false } } Plutôt concis, ça vaut clairement le coup plutôt que de perdre ces quelques variables dans des chemins trop tortueux.\nTous mes proches le savent, les enums Swift c’est ma grande passion. Et ceux du petit routeur ci-dessus me permettent de faire des fonctions SwiftUI bien compactes :\nfunc alert() -\u003e Alert { switch vm.router.activeAlert { case .confirmAttestation: return Alert(title: coldFeetTitle, message: coldFeetMessage, primaryButton: .default(Text(\"Je certifie\")) { vm.generateNewAttestation() }, secondaryButton: .cancel(Text(\"Annuler\"))) case .detail(reason: let reason): return Alert(title: Text(reason.niceString), message: Text(reason.detail), dismissButton: .default(Text(\"Ok\"))) } } func sheet() -\u003e AnyView { switch vm.router.activeSheet { case .attestationPresentation(let person): return AnyView(AttestationView(vm: vm.attestationViewModel(person: person))) case .addPerson: return AnyView(AddOrEditPersonSheet(vm: vm.addPersonViewModel)) case .edit(let person): return AnyView(AddOrEditPersonSheet(vm: vm.editPersonViewModel(person: person))) } } Et enfin, le body de ma View principale sera très concis :\nvar body: some View { NavigationView { VStack(alignment: .center, spacing: 5) { MainListsView(model: vm.mainListsViewModel).environment(\\.editMode, $editMode) BottomMenu(model: vm.bottomMenuViewModel) } .sheet(isPresented: $vm.router.showSheet, onDismiss: { vm.checkShouldShowPinnedAttestation() }, content: sheet) .navigationBarTitle(\"\", displayMode: .inline) .navigationBarItems(leading: navigationBarLeadingItem, trailing: EditButton(editMode: $editMode)) } .alert(isPresented: $vm.router.showAlert, content: alert) } (on peut comprendre d’ailleurs pourquoi je sépare le showSheet et showAlert des enums, au lieu de déclarer des .none)\nLa vue principale est la principale consommatrice du routeur, cependant de multiples vues viennent agir dessus.\nEvidemment, cette architecture est adaptée à ce projet particulier, ne cherchez pas à reproduire ça à la maison.\nLes petits trucs pénibles Type erasure Ci-dessus, vous pouvez voir que j’utilise AnyView(...) pour renvoyer un type consistant de View. Pour tous ceux qui ont joué un peu en profondeur avec les protocoles et génériques en Swift, on atteint vite des obstacles mystérieux particulièrement brainboiling.\nHeureusement on observe un effort de type erasure dans les bibliothèques système avec ces AnyView, AnyCancellable…\nAinsi que de nouveaux mots clé mystérieux comme some qui est la réponse directe à la sentence :\n Protocols ‘WouldBeSoNice’ can only be used as a generic constraint because it has Self or associated type requirements\n Si ça vous intéresse je vous conseille ce petit article.\nCeci-dit, même si ça disparaît vite, je pense que c’est un frein assez considérable notamment pour des débutants.\nObserver des objets imbriqués Un ViewModel en mode Combine doit avoir cette allure :\nclass MyViewModel : ObservableObject { @Published var someProperty = \"Coucou copaing !\" } Le wrapper @Published est tout à fait adaptée aux structs puisque toute mutation d’une struct est un changement de valeur. Mais les classes si elles sont faites pour être mutées ne remonteront point l’évènement au wrapper.\nOr pour observer une propriété imbriquée au deuxième niveau dans SwiftUI, comme .sheet(isPresented: $vm.router.showSheet) {…}, on peut essayer :\n d’observer le routeur qui serait une struct et de prendre sa valeur showSheet avec le routeur en ObservableObject, observer directement showSheet  Eh bien aucune des deux options ne fonctionne directement depuis une vue SwiftUI. Ce petit $ qui désigne la projectedValue d’une propriété encapsulée par un @Published ou un @State n’est pas magique, et ça ne fonctionne qu’au premier niveau, c’est à dire un @Published propriété d’un ObservableObject.\nEt la feinte officielle n’est pas bien glorieuse :\nclass MyViewModel : ObservableObject { @Published var router = Router private var cancellables = Set\u003cAnyCancellable\u003e() init(router: Router) { self.router = router router.objectWillChange.sink { [weak self] _ in self?.objectWillChange.send() }.store(in: \u0026cancellables) } deinit { cancellables.forEach({ $0.cancel() }) } } Il-y-a des variantes plus concises au prix de sacrifices discutables, mais voilà le principe. A chaque fois que le routeur va changer, on va propager l’évènement pour indiquer à l’UI de se rafraîchir. C’est un peu large, un peu “Mario fait du Combine”, mais ne soyons pas obtus, si ça roule après tout…\nUne bonne alternative est de mettre tout ça à plat dans la vue :\nstruct MyView: View { @ObservedObject private var vm: MainViewModel var body: some View {...} } deviendrait\nstruct MyView: View { @ObservedObject private var vm: MyViewModel @ObservedObject private var router: Router var body: some View {...} } C’est plus élégant je trouve, mais imaginons que j’ai 8 entités un peu complexes à embarquer dans mon VM, ça commence alors à foisonner plus que de raison.\nAutre point en passant, impossible de sécuriser l’instance embarquée du routeur dans le view-model avec un private(set) modifier dans la première version. C’est de l’ordre du TOC - c’est bien d’en être conscient - mais ça me gène 😅\nPropager des @Published, Model -\u003e VM -\u003e View class Store : ObservableObject { @Published private(set) var someUrl: URL? } class MyViewModel : ObservableObject { @Published private(set) var someUrl: URL? init(store: Store) { store.$someUrl.assign(to: \u0026$someUrl) } } Mais c’est très raisonnable, super ! Oui mais iOS14+ seulement.\nEt voici la version iOS 13 :\nclass Store : ObservableObject { @Published private(set) var someUrl: URL? } class MyViewModel : ObservableObject { @Published private(set) var someUrl: URL? private var cancellables = Set\u003cAnyCancellable\u003e() init(store: Store) { store.$someUrl.sink { [weak self] url in self?.someUrl = url }.store(in: \u0026cancellables) } deinit { cancellables.forEach({ $0.cancel() }) } } * whip sound *\nPas mal hein ?\n* whip sound *\nSink twice silence génant\nQuand on observe un sujet avec sink, sachez que la valeur qui vous est passée en closure est celle qui va être attribuée, comme lorsqu’on utilise willSet sur une propriété (quelques détails ici).\nPas de problème pour l’update d’UI, c’est fait pour. Mais pour les autres besoins, comme par exemple quand on a des mécanismes complexes intermédiaires qui ne se résument pas à fusionner deux valeurs publiées, la meilleure chose à faire est encore de créer son publisher.\nEt même si j’aurais encore beaucoup à dire autour de ce sujet, je réserve à un futur article une petite contribution autour de ce sujet, des property wrappers et consorts.\nN’hésitez pas à m’écrire si vous avez un avis quelconque sur ce que j’ai écrit, mon email est (?) dans le footer ;)\n","description":"","tags":["iOS","Combine","SwiftUI"],"title":"SwiftUI \u0026 Combine Feedback #1 : architecture et grains de sable","uri":"/posts/swiftui_combine1/"},{"categories":["Application mobile"],"content":"Il m’est arrivé plusieurs fois d’oublier mon attestation de sortie (c’est mal), de la générer au volant en panique (c’est très mal), de prendre du retard en tapant le formulaire avant de partir… Loin de moi l’idée de débattre du bien-fondé du confinement et de ses modalités, cependant j’étais confronté à un inconfort mineur. Et comme tout bon ingé, j’ai cherché et évalué des solutions complètement superflues - toutefois avec un indiscutable sérieux et un professionnalisme inébranlable.\nLa voie des anciens Imprimer des attestations préremplies et ne laisser que le motif, la date, l’heure et la signature à remplir.\nOui ça marche, mais la matérialisation est une contrainte forte. Si on oublie de remplir son attestation (c’est mal) et qu’on prend la voiture on n’a pas de moyen de gérer la situation sans un 180° bien crissant (ce qui est certes classe mais dangereux).\nOn me dit dans l’oreillette qu’on peut tout à fait écrire une attestation à la main sur papier libre… Oui mais bon, change pas de sujet, j’ai pas de stylo ni de papier sur moi, voilà, et puis niveau ergonomie, c’est so les millénaires passés l’écriture…\nLa voie officielle #1 (web) J’ai essayé de faire avec la page web gouvernementale. Et franchement, c’est correct sur ordinateur avec le bon équipement logiciel. J’utilise personnellement un navigateur Chromium avec le plugin de mon gestionnaire de mots de passe Dashlane. Le seul inconfort évident est la lecture des motifs du déplacement. J’ai commencé à faire un petit plugin Chrome pour retravailler ça avant de me raviser rapidement : les plugins ne fonctionnent pas sur les navigateurs Chromium iOS et la génération sur portable est bien plus pratique.\nLa voie officielle #2 (TousAntiCovid) On monte en qualité avec le générateur intégré à l’application TousAntiCovid. Il est possible de faire retenir mes coordonnées par l’appli et les motifs ont un titre en gras qui permet d’y voir un peu plus clair. Cependant je ne suis pas intéressé par la fonctionnalité de traçage de cette application. Donc je n’ai pas apprécié quand j’ai dû impérativement autoriser l’app à utiliser le bluetooth à la première ouverture. Et puis en regardant ça, je commençais à avoir ma petite idée de l’appli idéale donc toutes les petites frictions du parcours pour générer mon autorisation me faisaient tiquer. Ca fait quand même pas mal d’étapes après ouverture de l’application :\n scroll tout en bas tap sur Attestation de déplacement tap sur Nouvelle attestation entrer mes données - ok ça s’enregistre on ne le compte pas tap (optionnel) sur l’heure pour régler l’heure de ma sortie - je n’ai jamais touché à la date jusque là tap pour choisir le motif de déplacement (qui ne s’enregistre pas) sur mon iPhone, il faut 3 hauteurs d’écran pour lire intégralement la liste des motifs, on ajoute donc souvent un scroll ou deux tap sur le motif tap sur Générer alerte de confirmation : tap sur Je certifie  Donc dans le cas idéal (je pars maintenant, c’est bien moi qui gènère l’attestation et je suis la dernière personne à avoir utilisé le générateur sur cet appareil, et mon motif est mon caractère laborieux) j’ai donc 7 actions avant d’obtenir le QR Code tant convoité. C’est beaucoup.\nLa voie des ptits malins (app iOS Raccourcis) Certaines boîtes comme Luko ou Newzik vous proposent de générer un lien qui contient vos données, et qui mène à un générateur automatique qui affiche l’attestation générée avec l’heure de sortie actuelle.\nL’idée est notamment d’utiliser un raccourci déclenché par Siri par exemple pour commander son attestation à la voix ou encore la faire ouvrir automatiquement dès qu’on quitte son domicile. On n’est pas loin de la solution idéale, seulement je ne peux pas générer une attestation à la bourre.\nCeci-dit, ce lien est un bon exemple de ce qu’on peut faire rapidement pour se faciliter la vie. Quelques bookmarks, un peu de configuration et pour les gens pas trop technophobes on s’en sort.\nL’app de mes rêves Cahier des charges L’app de mes rêves\n dans le meilleur des cas, nécessite une seule action pour générer une attestation si le motif change, une à deux actions supplémentaires sont tolérables. demande le plus rarement possible des actions supplémentaires. permet à ma compagne de faire son attestation sur mon téléphone sans effacer mes données préremplies gère très efficacement mon cas pathologique d’oubli. Elle doit donc me permettre de générer mon attestation lorsque je me rends compte après 20 minutes de trajet que j’ai oublié mon attestation : pour être dans les clous, mon heure de sortie doit alors être 20 minutes dans le passé n’embarque aucune autre fonctionnalité non souhaitée n’envoie aucune donnée à qui que ce soit (pas de tracking publicitaire ou autre) n’utilise aucune bibliothèque tierce non maîtrisée à 100%  Je me suis auto-défié, et au bout d’une petite journée de développement j’avais un prototype fonctionnel, ce qui m’a encouragé à continuer. Au bout de trois jours de développement j’avais une app présentable, les aspects légaux étaient confirmés, et la plupart des raffinements majeurs étaient implémentés.\nRéalisation ! Je suis bien content d’annoncer que j’ai respecté *presque* tous les points de l’app de mes rêves. Seule entorse, comme il faut quand même être un peu sérieux, j’ai ajouté une confirmation de véracité des données à la génération de l’attestation, on a donc deux actions pour générer l’attestation.\nTout comme pour la solution de génération par liens, j’ai récupéré le code publié par le ministère de l’intérieur pour générer les PDFs en inspectant son intégralité, en extrayant uniquement les parties nécessaires, puis en le modifiant pour son intégration dans l’app.\nJe ne vais pas vous cacher que je n’aurais pas fait cette application juste pour me faciliter les sorties. Je voulais également expérimenter SwiftUI, la bibliothèque déclarative d’interface utilisateur d’Apple qui me tend les bras depuis plusieurs années, et c’était une bonne occasion.\nEt voici le résultat :\nVue principale Ici on peut :\n ajouter / supprimer / réordonner les personnes sélectionner un ou plusieurs motifs de sortie sélectionner la date de sortie en temps relatif par rapport à l’heure actuelle : les boutons du Stepper (+ / -) ajoutent ou retirent 10 minutes et surtout aller vers l’attestation !  Vue d’édition de personne Un simple formulaire tout bête :)\nPrésentation de l’attestation Très simple, on peut juste :\n partager le PDF épingler l’attestation : dans ce cas la présentation en carte ne se laisse pas fermer comme d’habitude par swipe vertical, la croix de fermeture disparaît, et au cas où l’utilisateur ferme l’app, l’attestation sera restaurée à la réouverture  Temps de génération de l’attestation : 3s Dans mon usage quotidien, avec ma (vraie) identité de remplie, je mets environ 3s à remplir mon attestation entre l’ouverture de l’app, le choix ou la vérification du motif et le réglage ou la vérification de l’heure. Oui je suis lent, mais mon objectif est atteint, je peux sans risque générer mon attestation dans des situation d’urgence et d’oubli \\o/\nApp Store ? Eh bien malgré ma gestion paranoïaque des données utilisateur, il semble que ce ne soit pas suffisant pour Apple qui (je pense) n’autorise simplement aucune app avec cette fonctionnalité sauf celle du gouvernement.\n We found in our review that your app provides services or requires sensitive user information related to the COVID-19 pandemic. Since the COVID-19 pandemic is a public health crisis, services and information related to it are considered to be part of the healthcare industry. In addition, the seller and company names associated with your app are not from a recognized institution, such as a governmental entity, hospital, insurance company, non-governmental organization, or university.\nPer section 5.1.1 (ix) of the App Store Review Guidelines, apps that provide services or collect sensitive user information in highly-regulated fields, such as healthcare, should be submitted by a legal entity that provides these services, and not by an individual developer.\n J’ai évidemment fait appel mais je ne pense pas qu’ils cèderont, tant pis, je ne partagerai donc mon app qu’avec mes proches (du moins ceux qui possèdent un iPhone) !\nDéveloppement : retour d’XP SwiftUI + Combine Tout d’abord SwiftUI est très agréable à utiliser. On a évidemment les traditionnelles errances de XCode 12, que ce soit niveau compilation, complétion, aperçu de l’UI… Mais il convient de saluer la prouesse qu’est l’implémentation de ce framework, un très bon exemple de DSL sur Swift, qui s’y prête particulièrement bien.\n1struct AddEditPersonSheet: View { 2 3\t// Local state 4 @State 5 private var tappedOkButton = false 6\t7\t// The ViewModel data and callbacks / Yeah I should have created a struct for this 8 @Binding 9 var editingPerson: EditingPerson 10 let isCreation: Bool 11 var cancelAddPerson: () -\u003e Void 12 var endAddOrEditPerson: () -\u003e Void 13 14\t// No constructor (structs are cool) 15\t16 private var title: String { 17 isCreation ? \"Créer\" : \"Modifier\" 18 } 19 20 private func isEmpty(_ str: String) -\u003e Bool { 21 str.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty 22 } 23 24 var body: some View { 25 NavigationView { 26 Form {ss 27 Section(header: Text(\"Identité\")) { 28 if tappedOkButton \u0026\u0026 isEmpty(editingPerson.firstName) { 29 Text(\"Prénom manquant\").foregroundColor(.red) 30 } 31 TextField(\"Prénom\", text: $editingPerson.firstName).textContentType(.givenName) 32 if tappedOkButton \u0026\u0026 isEmpty(editingPerson.lastName) { 33 Text(\"Nom manquant\").foregroundColor(.red) 34 } 35 TextField(\"Nom\", text: $editingPerson.lastName).textContentType(.familyName) 36 } 37 // ... other sections 38 } 39 .navigationBarItems(leading: Button(action: cancelAddPerson) { 40 Text(\"Annuler\") 41 }, trailing: Button(action: { 42 withAnimation { 43 tappedOkButton = true 44 if (editingPerson.isValid) { 45 endAddOrEditPerson() 46 } 47 } 48 }) { 49 Text(\"Enregistrer\") 50 }.disabled(tappedOkButton \u0026\u0026 editingPerson.isValid)) 51 .navigationBarTitle(Text(title), displayMode: .inline) 52 } 53 } 54} Pas de critiques les puristes, j’ai fait du monolingue et du gros inline volontairement.\nDéveloppement rapide : Grâce à cette approche DSL, on se retrouve avec du code à l’imbrication proche de l’UI, facilement intelligible, avec de très bons comportements par défaut. Comme c’était mon premier test j’ai forcément un peu ramé, mais j’aurais pris bien plus de 3 jours de développement pour une petite app complète, fonctionnelle et propre si j’avais dû rapprendre UIKit ou pire : HTML + CSS.\nLe couplage avec Combine permet de s’engager sur le chemin des state-driven apps. Pour avoir pas mal joué avec React + Redux, je ne peux que vous inciter à adopter ce paradigme. Evidemment, quand on n’a jamais fait que de la programmation impérative, beaucoup de petites choses peuvent être frustrantes au premier abord. Mais ça dégraisse tellement ! Et pour ceux qui ont déjà eu des interrogations philosophiques sur les architectures logicielles en iOS - entre MVC = Massive View Controller par exemple) et le trop souvent overkill VIPER -, SwiftUI + Combine incitent très naturellement à dérouler le code en MVVM, apportant enfin une alternative moderne et structurante.\nRIP UIKit ? : Bien sûr que non, SwiftUI est principalement une surcouche d’UIKit qui a encore de beaux jours devant lui. On peut d’ailleurs palier assez facilement l’absence de nombreux composants essentiels de SwiftUI en encapsulant une UIView, comme j’ai dû le faire pour le lecteur PDF et la webview qui appelle le code de génération du document PDF.\nC’est tout, ce fut un bon petit défi sympa et enrichissant !\nJ’espère avoir l’occasion de récrire sur Swift qui reste un de mes langages préférés, mais pour le moment je replonge dans mes projets TypeScript qui se positionne franchement pas mal non plus et a l’avantage d’être largement adopté en dehors du petit monde Apple.\n","description":"","tags":["iOS","Combine","SwiftUI","confinement","covid"],"title":"Attestation 2s iOS","uri":"/posts/attestation-ios/"}]
