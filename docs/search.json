[{"categories":["Game Theory"],"content":"Dans mon pr√©c√©dent billet, je vous parlais des fonctions d‚Äô√©valuation en th√©orie des jeux, plus particuli√®rement dans les tournois de poker No-Limit Hold‚ÄôEm (NLHE), et sp√©cifiquement de l‚ÄôIndependent Chip Model (ICM).\nPour rappel une fonction d‚Äô√©valuation donne une estimation probabiliste des gains de chaque joueur en fonction de l‚Äô√©tat du jeu. L‚ÄôICM utilise la taille des stacks des joueurs pour √©valuer leurs chances d‚Äôatteindre chaque rang dans le classement final du tournoi. Ces probabilit√©s multipli√©es par les prix de chaque rangs donnent une esp√©rance de gain en monnaie sonnante et tr√©buchante qui permettra aux joueurs de prendre des d√©cisions selon les issues possibles de ses actions.\nCalcul de l‚ÄôICM L‚ÄôICM suppose que la probabilit√© pour chaque joueur d‚Äôacc√©der √† la premi√®re place est √©gale √† la proportion repr√©sent√©e par son stack sur la totalit√© des jetons en jeu (la somme des stacks). R√©cursivement la probabilit√© pour un joueur A d‚Äôacc√©der √† la seconde place va √™tre une somme pour chaque autre joueur B en premi√®re place.\nSA = stack du joueur A SB = stack du joueur B P2A = probabilit√© du joueur A d'acc√©der √† la seconde place, initialis√© √† 0 Pour chaque autre joueur B: P1B = probabilit√© du joueur B d'√™tre premier = SB / Somme des stacks P2A_sachant_1B = probabilit√© du joueur consid√©r√© d'acc√©der √† la seconde place quand le joueur B acc√®de √† la premi√®re place P2A_sachant_1B = SA / (Somme des stacks - SB) P2A = P2A + P1B x P2A_sachant_1B Pour calculer le tableau de valeurs de l‚ÄôICM en fonction des stacks et des prix (payouts) on pourrait √©crire un algorithme de ce type :\npayouts = [Q1, Q2, Q3, ...] : prix pour la premi√®re, deuxi√®me, troisi√®me.. place. r√©sultat = [RA, RB, RC, ...] : tableau des r√©sultats, avec chaque valeur initialis√©e √† 0 pour tout classement possible des joueurs : (prenons le classement (A, B, C...) pour l'exemple) p = probabilit√© de ce classement = P1A x P2B_sachant_1A x P3C_sachant_1A_et_2B x ... RA = RA + p x Q1 RB = RB + p x Q2 RC = RC + p x Q3 ... Voici un bout de code python na√Øf qui fait √ßa :\nfrom itertools import permutations import numpy as np def icm_proba(permutation, stacks: np.ndarray, stacks_sum: int): result = 1 for rank, player in enumerate(permutation): stack = stacks[player] result *= stack / stacks_sum stacks_sum -= stack return result def icm(stacks: np.ndarray, payouts: np.ndarray) -\u003e np.ndarray: if len(stacks) == 0: return np.array([]) nb_stacks = len(stacks) stacks_sum = sum(stacks) result = np.zeros((nb_stacks,)) for permutation in permutations(range(nb_stacks)): probability = icm_proba(permutation, stacks, stacks_sum) for rank, player in enumerate(permutation): result[player] += probability * payouts[rank] return result if __name__ == '__main__': val = icm(np.array([500, 300, 200]), np.array([600, 400, 0])) print(val) Output :\n[435.71428571 330. 234.28571429] On note la finesse du formattage\nComplexit√© Prendre tout classement possible de N joueurs, c‚Äôest ce qu‚Äôon appelle une permutation ou encore un arrangement. Et on calcule tr√®s facilement combien il existe d‚Äôarrangement pour un nombre donn√© de joueurs :\n1 : 1 (ben oui) 2 : 2 x 1 = 2 (jur√© √ßa change apr√®s) 3 : 3 x 2 x 1 = 6 4 : 4 x 3 x 2 x 1 = 24 5 : 5 x 4 x 3 x 2 x 1 = 120 C‚Äôest la factorielle, et on peut voir que √ßa croit tr√®s rapidement (plus vite qu‚Äôune exponentielle). Si on code √ßa comme √ßa on obtient une complexit√© tellement violente qu‚Äôil est difficile de calculer l‚ÄôICM au del√† de 10 joueurs dans un temps raisonnable.\nPar exemple avec le code ci-dessus j‚Äôai obtenu ces temps :\n3.695487976074219e-05 seconds for 2 players 2.8848648071289062e-05 seconds for 3 players 8.177757263183594e-05 seconds for 4 players 0.0006070137023925781 seconds for 5 players 0.0037360191345214844 seconds for 6 players 0.027889013290405273 seconds for 7 players 0.24523401260375977 seconds for 8 players 2.2415449619293213 seconds for 9 players 23.641671180725098 seconds for 10 players Je vous rappelle qu‚Äô√† l‚Äôorigine, je m‚Äôint√©resse √† l‚ÄôICM en tournoi multi-table. C‚Äôest √† dire dans des tournois o√π le nombre de joueur est entre dix et‚Ä¶ quelques milliers.\nDe plus, quand je regarde par exemple sur HoldemRessources, leur calculateur me r√©pond en environ 200ms pour une vingtaine de joueurs. M√™me si ils ont mis un serveur tr√®s performant, on est dans des ordres de grandeur tr√®s lointains. On peut faire beaucoup mieux.\nPremi√®re optimisation : passer en r√©cursif et en C++ Eh oui car le Python n‚Äôest rapide que quand il appelle des biblioth√®ques compil√©es. Faisons-donc la notre ! Et j‚Äôen profite pour faire une version r√©cursive de l‚Äôalgorithme qui va nous √©conomiser pas mal de multiplications pour le calcul de probabilit√©. En effet, on regroupe toutes les permutations pour lesquelles le premier joueur dans le classement est le joueur d‚Äôindex 0 dans les stacks par exemple, mais voyez plut√¥t ci-dessous.\nAu premier appel, la fonction recursiveNaiveIcm va √©num√©rer tous les joueurs possibles en premi√®re place. Pour chacun, elle va s‚Äôappeler elle-m√™me pour la seconde place, etc.\nvoid recursiveNaiveIcm(const vector\u003cdouble\u003e \u0026stacks, const vector\u003cdouble\u003e \u0026payouts, vector\u003cdouble\u003e \u0026result, vector\u003cbool\u003e \u0026usedPlayers, const int rank, const int size, const double factor, const double stacksSum) { if (rank == size) { // No player to rank left  return; } for (int i = 0; i \u003c size; i++) { if (usedPlayers[i]) { continue; } // ith player has already been considered  // The probability to have this ith player at this rank knowing the previous ranking is stacks[i] / stacksSum  // The total probability of this ranking chain is thus :  const double newFactor = factor * stacks[i] / stacksSum; // Let's remember this player is ranked  usedPlayers[i] = true; // Add his pondered payout to the result  result[i] += newFactor * payouts[rank]; // Rank all possible next players  recursiveNaiveIcm(stacks, payouts, result, usedPlayers, rank + 1, size, newFactor, stacksSum - stacks[i]); // Reset the flag  usedPlayers[i] = false; } } // Entry point vector\u003cdouble\u003e naiveIcm(const vector\u003cdouble\u003e \u0026stacks, const vector\u003cdouble\u003e \u0026payouts) { const int size = stacks.size(); // Number of players  vector\u003cdouble\u003e result(size); vector\u003cbool\u003e usedPlayers(size); // Flags to note down players that were already considered  double stacksSum = accumulate(stacks.begin(), stacks.end(), 0.); recursiveNaiveIcm(stacks, payouts, result, usedPlayers, 0, size, 1, stacksSum); return result; } Je n‚Äôavais pas fait de C++ depuis plus de 10 ans alors on ne se moque pas. De mon temps on codait en C++98, on avait une orange √† No√´l, et on √©tait content !\nVoyons ce qu‚Äôon gagne en temps d‚Äôex√©cution :\nDuration 0ms for 2 players Duration 0ms for 3 players Duration 0ms for 4 players Duration 0ms for 5 players Duration 0ms for 6 players Duration 0ms for 7 players Duration 2ms for 8 players Duration 18ms for 9 players Duration 177ms for 10 players Duration 2087ms for 11 players Duration 25924ms for 12 players Pas mal, on peut ajouter un onzi√®me et un douzi√®me joueurs pour presque le m√™me temps de calcul. En gros, on a une acc√©l√©ration de 11 x 12, donc de l‚Äôordre de la centaine !\nMais √ßa ne nous emm√®ne pas si loin. Continuons de gratter !\nDeuxi√®me optimisation : cache et C-moins-moins Supposons que nous avons n joueurs. √Ä un moment du calcul o√π on a d√©fini les rangs des k premiers joueurs, il reste n - k joueurs dont on va √©num√©rer les diff√©rentes classements possibles.\nSi on prend ces m√™mes k premiers joueurs mais dans un autre ordre, l‚Äô√©num√©ration des diff√©rents classements des n - k joueurs restants va √™tre presque identique :\n size, stacks et payouts ne bougent pas result est la destination, ce n‚Äôest pas un param√®tre du calcul usedPlayers a les m√™mes indexes √† true (correspondant aux k joueurs class√©s) rank = k, c‚Äôest le m√™me stacksSum correspond √† la somme des stacks des n - k joueurs restants et a la m√™me valeur  En fait, seul le param√®tre factor varie, car la probabilit√© d‚Äôavoir les k premiers joueurs class√©s dans un ordre ou un autre n‚Äôest pas la m√™me.\nCependant, ce facteur est finalement appliqu√© √† toutes les contributions des appels imbriqu√©s. Mais on peut donc l‚Äôextraire et l‚Äôappliquer a posteriori.\nCe-faisant, on va calculer une seule fois cette sous-partie pour n - k joueurs au lieu de la calculer pour chaque classement des m√™mes k premiers joueurs.\nSi en plus on applique √ßa pour tous les k entre 0 et n - 1, on n‚Äôa en fait √† calculer la sous partie que pour toutes les combinaisons (de taille 1 √† n) de joueurs.\nHors on sait tr√®s bien d√©nombrer √©galement le nombre de combinaisons possible de joueurs parmis n, et c‚Äôest 2n. J‚Äô√©voquais tout √† l‚Äôheure la complexit√© factorielle de l‚Äôalgorithme na√Øf, la r√©duire √† une complexit√© exponentielle semble prometteur !\nPour ajouter encore un peu de perf, je vous mets avec √ßa :\n des pointeurs old-sChool plut√¥t que des vectors un bitmask pour les usedPlayers plut√¥t qu‚Äôun tableau de bool√©ens  et voici ce que √ßa donne :\nvoid recursiveIcm(const double *stacks, const double *payouts, double *result, long long usedPlayers, int rank, int size, double factor, double stacksSum, double *cacheValues, bool *cacheFlags) { if (rank == size) { return; } double *subResult = cacheValues + usedPlayers * size; // If the subResult wasn't computed previously, let's do it  if (!*(cacheFlags + usedPlayers)) { for (int i = 0; i \u003c size; i++) { const long long iMask = 0x1ll \u003c\u003c i; if (usedPlayers \u0026 iMask) { continue; } const double newFactor = stacks[i] / stacksSum; subResult[i] += newFactor * payouts[rank]; recursiveIcm(stacks, payouts, subResult, usedPlayers | iMask, rank + 1, size, newFactor, stacksSum - stacks[i], cacheValues, cacheFlags); } *(cacheFlags + usedPlayers) = true; } for (int i = 0; i \u003c size; ++i) { result[i] += factor * subResult[i]; } } vector\u003cdouble\u003e icm(const vector\u003cdouble\u003e \u0026stacks, const vector\u003cdouble\u003e \u0026payouts) { const int size = stacks.size(); double result[size]; fill_n(result, size, 0); double stacksArray[size]; double payoutsArray[size]; for (int i = 0; i \u003c size; ++i) { stacksArray[i] = stacks[i]; payoutsArray[i] = payouts[i]; } const double stacksSum = accumulate(stacks.begin(), stacks.end(), 0.); const auto cacheEntrySize = size * sizeof(double); // One double for each player  auto cacheValues = (double *) calloc(pow(2, size), cacheEntrySize); auto cacheFlags = (bool *) calloc(pow(2, size), sizeof(bool)); recursiveIcm(stacksArray, payoutsArray, result, 0, 0, size, 1, stacksSum, cacheValues, cacheFlags); vector\u003cdouble\u003e toReturn(size); for (int i = 0; i \u003c size; ++i) { toReturn[i] = result[i]; } free(cacheValues); free(cacheFlags); return toReturn; } Mais surtout le r√©sultat en termes de performance :\nDuration 0ms for 2 players Duration 0ms for 3 players Duration 0ms for 4 players Duration 0ms for 5 players Duration 0ms for 6 players Duration 0ms for 7 players Duration 0ms for 8 players Duration 0ms for 9 players Duration 0ms for 10 players Duration 0ms for 11 players Duration 1ms for 12 players Duration 1ms for 13 players Duration 3ms for 14 players Duration 7ms for 15 players Duration 19ms for 16 players Duration 51ms for 17 players Duration 130ms for 18 players Duration 321ms for 19 players Duration 737ms for 20 players Conclusion et quoi-est-apr√®s J‚Äôai toujours en t√™te de comparer et de titiller les fonctions d‚Äô√©valuation en MTT. J‚Äôai maintenant une biblioth√®que de calcul de l‚ÄôICM de qualit√© professionnelle, qui m‚Äôautorise des simulations de tournois pour un petit nombre de joueur. √áa peut √™tre suffisant pour faire des tests qualitatifs sur quelques joueurs, mais j‚Äôai envie de voir si je peux aller plus loin.\nComment calculer efficacement l‚ÄôICM pour 50 joueurs ? Ce sera tr√®s probablement le sujet de mon prochain billet !\n","description":"O√π on calcule avec brutalit√© les esp√©rances des joueurs selon un mod√®le ind√©pendantiste.","tags":["Poker","AI","ICM","MTT","Game Theory"],"title":"Poker : MTT et ICM - Le Calcul Brutal","uri":"/posts/poker_mtt_icm_calcul/"},{"categories":["Game Theory"],"content":"Comme beaucoup, j‚Äôai eu ma p√©riode ‚Äúpoker‚Äù. Elle s‚Äôest tr√®s vite traduite chez moi par la conception d‚Äôoutils divers d‚Äôaide et d‚Äôanalyse de jeu (parce que je suis trop mauvais), et a donn√© naissance √† cette petite biblioth√®que Java. J‚Äôai tir√© beaucoup de cette exp√©rience, que ce soit en th√©orie des jeux, en algorithmique th√©orique et pratique, en intelligence artificielle ou m√™me en architecture logicielle. Alors bon, je n‚Äôassume pas tout √† fait cette vieille lib, ‚Äúsi je devais la recoder je le ferais diff√©remment‚Äù‚Ñ¢ - pas en Java notamment - mais √ßa fait partie de ces projets tentaculaires qui vous portent pendant des ann√©es et vous font monter en comp√©tence sur un large front dans l‚Äôall√©gresse.\n√áa me titillait depuis longtemps de trouver un sujet dans le domaine et de bonnes raisons de m‚Äôy recoller. Quand soudain, je tombai sur le paradoxe de Saint-P√©tersbourg qui relan√ßa avec un ami une vieille conversation sur l‚Äô√©valuation de l‚ÄôEV (expected value) en MTT (multi-table tournament).\nIl se trouve que la question ‚ÄúFaut-il jouer toutes les mains EV+ ICM en tournoi?‚Äù impliquait un long p√©riple avec dedans du machine-learning, des simulations de jeu et des mod√©lisations int√©ressantes - tout ce que j‚Äôadore.\nMais revenons au d√©but, je vais commencer dans ce billet par tenter de vous expliquer la question.\nTh√©orie des jeux Au poker, on cherche souvent √† jouer GTO (Game Theory Optimal). Derri√®re ce terme, beaucoup d‚Äôimplicite. La th√©orie des jeux √©tudie les interactions strat√©giques d‚Äôagents √† cheval entre les math√©matiques et les sciences sociales, avec de tr√®s int√©ressantes questions qu‚Äôon va oublier bien vite : Comment d√©finit-on la rationalit√© des agents ? Est-elle normative ou prescriptive ? Quelles qualit√©s descriptives a-t-elle ?\nVoil√†, on oublie, et maintenant on constate que dans la plupart des cas, tout le monde cherche √† trouver la meilleure mani√®re de jouer pour gagner - que ce soit aux √©checs, au poker, au go ou √† Starcraft1.\nDans des jeux comme les √©checs, les algorithmes n‚Äôexplorent pas l‚Äôensemble de l‚Äôarbre de jeu mais √©valuent un certain nombre de coups √† l‚Äôavance. Si je regarde les 5 prochains coups possibles et que sur cette base je dois faire un choix, il me faut √©valuer la valeur de chaque situation future r√©sultant de chaque combinaison possible de 5 actions. On appelle fonction d‚Äô√©valuation cette estimation de la valeur d‚Äôune situation qui n‚Äôest pas une situation finale. Dans des jeux faisant intervenir la chance (l‚Äôal√©atoire), on la confond souvent avec la valeur statistique d‚Äôesp√©rance (EV, Expected Value : l‚Äôesp√©rance), car on va prendre les d√©cisions en fonction de l‚ÄôEV calcul√© gr√¢ce la fonction d‚Äô√©valuation. EV+ signifie ainsi ‚Äúd‚Äôesp√©rance positive‚Äù.\nPoker Le poker est un jeu de taille consid√©rable du fait du nombre de combinaisons de cartes multipli√© par le nombre de s√©quences d‚Äôaction (mises) de jeu possibles. Je parle ici uniquement du No-Limit Hold‚ÄôEm (NLHE) qui est la variante la plus commune.\nDans le cas du cash-game o√π les jetons mis√©s valent une somme d√©termin√©e d‚Äôargent, le probl√®me de l‚Äôoptimisation de la strat√©gie est circonscrit √† une main. Cela reste √©norme en complexit√© mais permet aux explorations algorithmiques de ne pas recourir √† des fonctions d‚Äô√©valuation interm√©diaire, et d‚Äôinterpr√©ter directement les gains et pertes futurs r√©sultant des actions en terme d‚Äôargent.\nEn effet, lorsqu‚Äôon va chercher √† √©valuer si telle action est pr√©f√©rable √† telle autre, on va faire ce genre de calcul :\n Si je me couche, √† la fin de la main j‚Äôai un stack (un tapis) de 900 jetons. Si je suis la mise, selon les cartes qui vont √™tre r√©v√©l√©es :  j‚Äôai 40% de chances de finir avec un stack de 1300 jetons j‚Äôai 60% de chances de finir avec un stack de 500 jetons    Je peux donc calculer mon esp√©rance :\n Me coucher : 900 jetons Suivre : 0,4 x 1300 + 0,6 x 500 = 820 jetons  Ok, je dois donc rationnellement me coucher, car plus (+) de jetons, c‚Äôest mieux.\nTournoi Dans un tournoi cependant, les prix sont attribu√©es selon la place finale d‚Äôun joueur. Prenons le cas de trois joueurs qui doivent partager 1000‚Ç¨ de prix et disposent en tout de 1000 jetons. Nous ne connaissons rien des joueurs, si bien qu‚Äôon les consid√®re aveugl√©ment √† √©galit√© strat√©gique.\nSi seul le premier joueur remporte les 1000‚Ç¨ il para√Æt raisonnable d‚Äôestimer leurs chances de gagner proportionnellement √† leurs stacks. On peut d‚Äôailleurs v√©rifier √ßa tr√®s facilement en leur faisant √©changer des jetons al√©atoirement (ce qui simule bien l‚Äô√©galit√© strat√©gique). Si les stacks sont 500, 300 et 200, alors en moyenne le premier joueur remportera la mise 50% du temps, le second 30% et le dernier 20%. Leurs esp√©rances de gain sont donc 500‚Ç¨, 300‚Ç¨ et 200‚Ç¨ respectivement.\nPetite simulation pour v√©rifier √ßa :\nimport numpy as np import random nb_simulations = 100000 players_stacks = [5, 3, 2] # We'll exchange chips one by one, so let's speed-up by setting smaller stacks payouts = [1000, 0, 0] nb_players = len(players_stacks) podiums = [] for i in range(nb_simulations): game_stacks = players_stacks.copy() podium = [] while True: in_game_players = [i for i, stack in enumerate(game_stacks) if stack \u003e 0] if len(in_game_players) == 1: # We have a winner podium = in_game_players + podium break # Exchange chips until one player is broke while True: # Randomly select two players random.shuffle(in_game_players) p1 = in_game_players[0] p2 = in_game_players[1] # And make them exchange one chip game_stacks[p1] += 1 game_stacks[p2] -= 1 # Is the losing player broke ? if game_stacks[p2] == 0: podium = [p2] + podium break # Recompute in_game_players podiums.append(podium) result = [0.0] * nb_players for podium in podiums: for i in range(nb_players): player = podium[i] result[player] += payouts[i] result = np.divide(result, nb_simulations) print(result) Output :\n\u003e [499.611 299.829 200.56 ] Ce qui m‚Äôa bien l‚Äôair de converger vers le r√©sultat attendu.\nPetite note sur la taille des stacks all√®grement divis√©e par 100 : il se trouve que √ßa n‚Äôa aucune influence, je l‚Äôai v√©rifi√© exp√©rimentalement. Cependant comme j‚Äôaimerais bien savoir pourquoi et que je n‚Äôai pas le temps de creuser, j‚Äôai pos√© la question √† l‚ÄôInternet.\n[EDIT] Au temps pour moi, la proportionalit√© n‚Äôest pas la seule √† compter. La taille des stacks a bien une influence dans le cas suivant o√π le second joueur a un prix ! Ceci-dit, m√™me si mes chiffres sont l√©g√®rement biais√©s √ßa n‚Äôinvalide en rien le propos.\nMaintenant, si le premier joueur remporte 600‚Ç¨ et le second 400‚Ç¨, a-t-on les m√™mes esp√©rances de gain ? Faisons donc tourner cette simulation avec ces payouts :\npayouts = [600, 400, 0] Output :\n\u003e [445.71 330.83 223.46] Il est tout de suite moins intuitif d‚Äôestimer √ßa √† vue de nez.\nICM Le jeu simul√© ci-dessus est le Gambler‚Äôs Ruin (qui est en soi plus un probl√®me th√©orique qu‚Äôun jeu).\nLa performance de cette simulation est tr√®s faible pour de nombreux joueurs avec de nombreux jetons. Il existe des techniques de calcul avanc√©es que je n‚Äôai pas encore explor√©es, car en pratique les joueurs de poker pr√©f√®rent mod√©liser leur esp√©rance de classement gr√¢ce √† l‚ÄôIndependent Chip Model (ICM) dont le calcul est bien plus simple.\nL‚ÄôICM est un mod√®le qui statue que la contribution √† l‚Äôacc√®s √† la premi√®re place du tournoi est la m√™me pour chaque jeton, puis r√©cursivement pour les places suivantes. On retrouve donc la proportionnalit√© entre les jetons et l‚Äôesp√©rance lorsque seul le premier joueur remporte le prix.\nAttention cependant, l‚ÄôICM n‚Äôest pas une solution du classement du probl√®me du N-players Gambler‚Äôs Ruin. C‚Äôest par contre une approximation commune.\nPour la situation ci-dessus, l‚ÄôICM nous donnera donc avec les stacks [500, 300, 200]:\nEn notant X_Y = le joueur X finit en Yi√®me position.\nP1_1 = 500 / 1000 = 0.5 P2_1 = 300 / 1000 = 0.3 P3_1 = 200 / 1000 = 0.2 Puis r√©cursivement, en appliquant la formule des probabilit√©s totales, on calcule la probabilit√© que le joueur 1 soit deuxi√®me :\nP1_2 = P2_1 * P(1_2 | 2_1) + P3_1 * P(1_3 | 3_1) P1_2 = 0.3 * (500 / 700) + 0.2 * (500 / 800) = 0,339 De m√™me pour les autres joueurs et ainsi de suite pour la troisi√®me place. Pour vous √©viter les calculs √† la main, il existe des calculateurs en ligne. Celui d‚ÄôHoldemResources et celui d‚ÄôICMIzer.\nPour notre situation, l‚ÄôICM nous donne les valeurs :\n\u003e [435.71 330.00 234.29] Pour comparer les r√©sultats, la simulation de Gambler‚Äôs Ruin nous donnait :\n\u003e [445.71 330.83 223.46] On retrouve un biais classique de l‚ÄôICM qui est de sous-estimer la valeur des plus gros stack et de surestimer les plus petits, tout en restant tr√®s correct pour les autres.\nR√©capitulatif Prenons un tout petit peu de recul. Pourquoi a-t-on besoin de cet ICM d√©j√† ?\nParce que lorsqu‚Äôon cherche une strat√©gie optimale, on doit estimer la valeur des situations vers lesquelles nous m√®nent nos actions potentielles. Dans le cas du cash-game, la valeur est imm√©diatement disponible en fin de main car elle est directement proportionnelle √† la quantit√© de jetons. Mais pour un tournoi, il faudrait aller jusqu‚Äô√† la r√©solution du tournoi entier pour observer le gain obtenu. Et autant dire que lorsqu‚Äôon doit d√©rouler toutes les possibilit√©s de tirages et d‚Äôactions futures, on pr√©f√®re circonscrire le probl√®me √† la main en cours pour avoir un r√©sultat avant la fin des temps dans le cas d‚Äôun calcul informatique.\nOn pr√©f√®rerait savoir calculer les esp√©rances de classement selon le mod√®le du Gambler‚Äôs Ruin, h√©las il est beaucoup plus compliqu√© d‚Äôavoir une performance correcte dans ce calcul (ceci dit √† ce sujet, j‚Äôai dans ma pile de lectures quelques papiers que j‚Äôexplorerai je l‚Äôesp√®re un de ces jours2).\nLa fonction d‚Äô√©valuation est un outil sur lequel on va soit entrainer des IA, soit faire des analyses strat√©giques avec des joueurs r√©els, mais elle ne repr√©sente pas l‚Äôesp√©rance concr√®te des joueurs la plupart du temps. Et c‚Äôest d‚Äôailleurs en g√©n√©ral ce qu‚Äôon souhaite, car essayer de se rapprocher des valeurs concr√®te c‚Äôest essayer de revenir √† la r√©solution du tournoi entier en utilisant strat√©gies calcul√©es sur la base de la fonction d‚Äô√©valuation‚Ä¶ Et c‚Äôest l‚ÄôOuroboros.\nPourtant on pourrait faire tendre vers plus de r√©alisme. Si on sait par exemple qu‚Äôun tournoi typique regroupe des joueurs de diff√©rents niveaux distribu√©s d‚Äôune mani√®re assez r√©guli√®re, mod√©liser ce fait statistique peut produire une fonction d‚Äô√©valuation plus adapt√©e √† l‚Äôentra√Ænement pour ce contexte de jeu. Car pour une IA, le jeu sur laquelle on l‚Äôentra√Æne inclut la fonction d‚Äô√©valuation. Sa confrontation au jeu r√©el sera lourdement affect√©e par le choix de cette fonction. On peut d‚Äôailleurs arbitrairement consid√©rer que le niveau des joueurs fait partie des donn√©es d‚Äôentr√©e de la fonction. Cependant on pr√©f√®re reporter ce genre de donn√©es contextuelles vers les algorithmes strat√©giques pour garder une fonction d‚Äô√©valuation g√©n√©rique et stable : l‚Äôappr√©ciation du niveau des joueurs est une donn√©e strat√©gique et contextuelle, elle sera donc int√©gr√©e comme une donn√©e d‚Äôentr√©e des m√©canismes strat√©giques.\nConclusion La question ‚ÄúFaut-il jouer toutes les mains EV+ ICM en tournoi?‚Äù prise litt√©ralement a une r√©ponse imm√©diate : non, il-y-a m√™me des ajustements que l‚Äôon sait b√©n√©fiques. Tout d‚Äôabord il est fort probable qu‚Äôune meilleure approximation du classement du Gambler‚Äôs Ruin donnerait de meilleurs r√©sultats, ensuite s‚Äôil √©tait possible de calculer une fonction d‚Äô√©valuation prenant en compte les asym√©tries du poker (tables de jeu et tours de parole) on augmenterait certainement encore la fiabilit√© de l‚Äô√©valuation.\nMais apr√®s cette question vient la suivante : peut-on trouver un meilleur mod√®le que l‚ÄôICM calculable efficacement ? Exp√©rimentalement par exemple, pourrait on appliquer des techniques modernes de machine learning pour trouver une fonction d‚Äô√©valuation qui surpasse l‚ÄôICM ? Et comment faire tout √ßa en pratique et pour un grand nombre de joueurs sachant que le calcul de l‚ÄôICM a une complexit√© factorielle ?\nDes d√©buts de r√©ponses dans un prochain billet !\n PS: dans ce billet, j‚Äôessaye de ne pas trop rentrer dans les d√©tails ce qui vaut des impr√©cisions et des raccourcis volontaires. N‚Äôh√©sitez cependant pas √† m‚Äô√©crire si vous trouvez √† redire, ou s‚Äôil-y-a des manques criants !\nPS bis: en cadeau, un petit papier sympa qui montre deux th√©or√®mes contre-intuitifs.\n Theorem 1. Suppose a tournament has prize money for nth place which is at least that for (n + 1)st place and that at least one player still in the tournament will not earn as much as second place prize money. Under the Independent Chip Model, any fair bet in which only one other player can gain or lose chips in the hand being played will lower the player‚Äôs expected prize money.\n  Theorem 2. Suppose a tournament has prize money for nth place which is at least that for (n + 1)st place and that at least one player still in the tournament will not earn as much as second place prize money. Under the Independent Chip Model, the expected prize money of any player not involved in a fair bet between two players will increase*\n Traduit √† la pelle par :\n Si t‚Äôes en duel avec une √©quit√© de 50% contre un seul adversaire au sein d‚Äôun tournoi avec des prix croissants, tu es perdant selon l‚ÄôICM. Si deux joueurs sont en duel dans ces m√™mes circonstances, tous les autres joueurs sont gagnants en ICM.    Ces jeux sont de natures tr√®s vari√©es. C‚Äôest ce qui fait d‚Äôailleurs qu‚Äô√† l‚Äôheure actuelle, les meilleures IA de poker sont bas√©es sur des techniques tr√®s diff√©rentes de l‚Äôimpressionnant MuZero de DeepMind (j‚Äôesp√®re avoir le temps de faire un petit papier ‚ÄúCFR vs Reinforcement Learning pour les nuls‚Äù tiens). ‚Ü©Ô∏é\n les papiers en question : Swan, Y., \u0026 Bruss, F. (2006). A matrix-analytic approach to the N-player ruin problem. Journal of Applied Probability, 43(3), 755-766. doi:10.1239/jap/1158784944, et Gambler‚Äôs Ruin and the ICM - arXiv:2011.07610v2. Et bien s√ªr toutes leurs r√©f√©rences üôÉ ‚Ü©Ô∏é\n   ","description":"O√π il est question des fonctions d‚Äô√©valuation en th√©orie des jeux, du Gambler‚Äôs Ruin et de l‚ÄôICM.","tags":["Poker","AI","ICM","MTT","Gambler's Ruin","Game Theory"],"title":"Poker : MTT et ICM - La Question","uri":"/posts/poker_mtt_icm_question/"},{"categories":null,"content":"Je suis architecte logiciel g√©n√©raliste et algorithmicien curieux. De l‚Äôid√©e √† la ligne de code, les choix sont innombrables et vari√©s. Distinguer ceux qui importent et les qualifier efficacement est aussi d√©terminant que l‚Äôexpertise technique.\nToujours motiv√© par la recherche de la solution la plus pertinente dans des contextes des plus communs aux plus complexes, contactez-moi pour me parler de vos projets :\n par email pitt@pittscraft.com par t√©l√©phone (ou Signal, Whatsapp, Telegram) au +33 (0)6 62 98 24 38  Pierre Mardon (Pitt)\n","description":"","tags":null,"title":"√Ä propos","uri":"/about/"},{"categories":["Application mobile"],"content":"J‚Äôavais d√©j√† crois√© un exemple d‚Äôimpl√©mentation de property wrapper et devant leur simplicit√©, je m‚Äô√©tais mis en t√™te de cr√©er un property wrapper acc√©l√©rant le stockage de valeurs dans les UserDefaults.\nIl se trouve que dans mes exp√©rimentations autour de Combine j‚Äôavais bien envie de cr√©er un wrapper publiant les nouvelles valeurs seulement apr√®s les avoirs stock√©es (voir ici).\nEt puis j‚Äôai finalement voulu faire tout en m√™me temps !\nQu‚Äôest-ce donc qu‚Äôun property wrapper ? Un property wrapper tr√®s simple s‚Äô√©crit de cette mani√®re :\n@propertyWrapper public class Print\u003cValue\u003e {ss private var val: Value public init(wrappedValue value: Value) { val = value } public var wrappedValue: Value { set { print(\"Setting '\\(val)'\") val = newValue } get { print(\"Returning '\\(val)'\") return val } } } et s‚Äôutilise ensuite ainsi :\nclass SomeClass { @Print var myString: String = \"Coucou copaing !\" func doThings() { myString = \"Bye friend\" var something = myString } } SomeClass().doThings() ce qui imprimera\n\u003e Setting 'Bye friend' \u003e Getting 'Bye friend' ce qui est plut√¥t nul.\nCeci-dit, si on d√©cidait de faire des choses plus int√©ressantes que des print, on pourrait bien se faciliter la vie !\nGot UserDefaults ? Stocker des propri√©t√©s dans les UserDefaults Voil√† un usage fr√©quent et int√©ressant.\n@propertyWrapper public struct UserDefaultsBacked\u003cValue\u003e { private let key: String private let defaultValue: Value private let storage: UserDefaults public init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard) { defaultValue = value self.key = key self.storage = storage } public var wrappedValue: Value { get { storage.value(forKey: key) as? Value ?? defaultValue} set { storage.setValue(newValue, forKey: key) } } } Et une impl√©mentation un peu na√Øve comme celle ci-dessus peut faire l‚Äôaffaire.\nUn petit warning quand m√™me, on n‚Äôoublie pas que chaque setValue sur une cl√© de UserDefaults r√©√©crit le dictionnaire complet. On utilisera donc tout √ßa en connaissance de cause, et n‚Äôoublions pas qu‚Äôon peut aussi r√©duire leur taille en n‚Äôutilisant pas syst√©matiquement le .standard.\nOn peut noter la pr√©sence de nouveaux arguments du constructeur, la key et le storage. Ils peuvent √™tre fournis via la d√©claration de l‚Äôannotation, ou doivent l‚Äô√™tre pour ceux qui n‚Äôont pas de valeur par d√©faut comme la key.\n@UserDefaultsBacked(\"int-key\") // Smells like Java var someInt = 8 @UserDefaultsBacked(\"my-data\", storage: UserDefaults(\"DBName\")) var someData: Data? = nil struct SomeStruct { var prop = \"Yup\" } @UserDefaultsBacked(\"my-struct\") var myStruct = SomeStruct() // Wait... What ? Stocker uniquement les types compatibles Ce wrapper fonctionnera tr√®s bien avec tous les types support√©s par les UserDefaults mais attendez-vous √† de bons crashes pour tous les autres cas, comme SomeStruct.\nRestreignons-donc d√©j√† l‚Äôusage aux bonnes valeurs gr√¢ce √† un flag protocol :\npublic protocol UserDefaultsStorable {} extension String : UserDefaultsStorable {} extension Int: UserDefaultsStorable {} extension Double: UserDefaultsStorable {} extension Float: UserDefaultsStorable {} extension Date: UserDefaultsStorable {} extension Data: UserDefaultsStorable {} extension Array: UserDefaultsStorable where Element: UserDefaultsStorable {} extension Dictionary: UserDefaultsStorable where Key == String, Value: UserDefaultsStorable {} @propertyWrapper public struct UserDefaultsBacked\u003cValue\u003e { private let key: String private let defaultValue: Value private let storage: UserDefaults public init(wrappedValue value: Value, key: String, storage: UserDefaults = .standard) where Value: UserDefaultsStorable { defaultValue = value self.key = key self.storage = storage } public var wrappedValue: Value { get { storage.value(forKey: key) as? Value ?? defaultValue} set { storage.setValue(newValue, forKey: key) } } } Ok, on a maintenant un property wrapper s√©lectif et une belle erreur de compilation dans le cas o√π le type ne se conforme pas √† UserDefaultsStorable.\n@UserDefaultsBacked(\"my-struct\") var myStruct = SomeStruct() // Error: Initializer 'init(wrappedValue:_:storage)' requires that 'SomeStruct' conform to 'UserDefaultsStorable' Stocker les Codables Bien mais SomeStruct n‚Äôest pas bien myst√©rieux, ce serait bien sympa de pouvoir le stocker aussi. En fait, tout codable est a priori stockable puisque Data l‚Äôest. Seulement pour √©viter de se faire la conversion √† chaque acc√®s, profitons donc de notre wrapper.\nG√©n√©ralisons : on peut avoir √† mapper les donn√©es dans un sens et dans l‚Äôautre pour pouvoir les stocker. L‚Äôinterface de UserDefaults utilise le tr√®s g√©n√©rique Any?, on va donc d√©finir les mappers :\ntypealias StoringMapper\u003cValue\u003e = (Value) -\u003e Any? typealias StoreReadingMapper\u003cValue\u003e = (Any?) -\u003e Value? Puis:\n d√©finir des propri√©t√©s de ce type dans notre wrapper. d√©finir un constructeur priv√© aveugle qui prend de bonne fois n‚Äôimporte quel type de propri√©t√© avec des mappers d√©finir des constructeurs publics stricts sur le type qui vont fournir des mappers au constructeur priv√©  @propertyWrapper public class UserDefaultsBacked\u003cValue\u003e { private let key: String private let storage: UserDefaults private let defaultValue: Value private var storingMapper: (Value) -\u003e Any? private var storeReadingMapper: (Any?) -\u003e Value? private init(wrappedValue value: Value, _ key: String , storage: UserDefaults, storingMapper: @escaping StoringMapper\u003cValue\u003e, storeReadingMapper: @escaping StoreReadingMapper\u003cValue\u003e) { var initValue = value if let storedValue = storeReadingMapper(storage.object(forKey: key)) { initValue = storedValue } defaultValue = initValue self.key = key self.storage = storage self.storingMapper = storingMapper self.storeReadingMapper = storeReadingMapper } public convenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value: UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, storingMapper: {$0}, storeReadingMapper: { $0 as? Value}) } public var wrappedValue: Value { get { storage.value(forKey: key) as? Value ?? defaultValue} set { storage.setValue(newValue, forKey: key) } } } Mais pour mes Codables les mappers ne sont pas si √©vidents.\npublic extension Encodable { func mapForStorage() -\u003e Any? { do { return try JSONEncoder().encode(self) } catch { print(\"Couldn't encode \\(self)\", error) return nil } } } Ci-dessus la fonction d‚Äôencodage, avec absolument pas de check sur le cas o√π l‚Äôobjet est √©galement stockable nativement, car la discrimination s‚Äôeffectuera en amont. Bon, c‚Äôest l‚Äô√©quivalent de try? JSONEncoder().encode(self) mais avec une trace pour ne pas √™tre compl√®tement dans le brouillard en cas de probl√®me. Evidemment on pr√©f√®rera certainement donner de meilleures options de tra√ßage, et certains se sentent mal (√† raison) de ne pas throw quoi que ce soit, mais ce n‚Äôest pas le d√©bat ici. Et puis comme on dit parfois : ‚ÄúQuand tout va bien, tout va bien !‚Äù.\n/// Simple type opening using a static function to allow JSON decoding with erased types conforming to `Decodable` protocol fileprivate extension Decodable { static func openedJSONDecode(using decoder: JSONDecoder, from data: Data) throws -\u003e Self { return try decoder.decode(self, from: data) } } Joyeusement pomp√© de ce post SO\nTiens je parlais dans mon poste pr√©c√©dent de type erasure, mais saviez vous que l‚Äôinverse est le type opening ? Eh bien pareil, je me suis couch√© moins b√™te. Et pour tous ceux qui ont d√©j√† jou√© avec un JSONDecoder dans des contextes g√©n√©riques un peu pouss√©s, la feinte ci-dessus est plut√¥t cool √† retenir : une fonction statique a toujours acc√®s au type concret, ce qui satisfait le compilo.\npublic extension Decodable { static func mapOutOfStorage(_ value: Any?) -\u003e Self? { guard let data = value as? Data else { return nil } do { return try Self.openedJSONDecode(using: JSONDecoder(), from: data) } catch { print(\"Couldn't decode \\(String(describing: value))\", error) // Very opinionated choice to ignore thrown errors return nil } } } Et voil√†, sur tout type se conformant √† Decodable on a d√©sormais cette fonction mapOutOfStorage.\nJe rappelle que typealias Codable = Decodable \u0026 Encodable, donc pour tout type Codable on a nos deux mappers \\o/\nRajoutons donc ce petit constructeur √† notre property wrapper UserDefaultsBacked :\nconvenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard) where Value : Codable { self.init(wrappedValue: value, key, storage: storage, storingMapper: Value.mapForStorage, storeReadingMapper: Value.mapOutOfStorage) } Nice, et maintenant qu‚Äôest ce qui se passe si je d√©clare quelque chose comme :\n@UserDefaultsBacked(\"myKey\") var myInt = 0 // Error: Ambiguous use of 'init(wrappedValue:_:storage:sendAfterStore:)' Eh bien les Int √©tant Codable mais aussi UserDefaultsStorable, le compilateur ne saura quel constructeur choisir. Deux solutions : enlever l‚Äôambiguit√© en changeant la signature d‚Äôun des constructeurs (ce qui est un peu minable, m√™me simplement d‚Äôy avoir pens√©), ou donner un constructeur qui match encore mieux, avec where Value : Codable \u0026 UserDefaultsStorable. Encore un bon trick, vous √™tes bienvenus.\nCheckpoint Voici un petit bilan :\n/// Any type implementing this protocol can be stored natively in UserDefaults public protocol UserDefaultsStorable {} /** Declare proper flag protocol conformance for all types natively compatible with UserDefaults storage */ extension String : UserDefaultsStorable {} extension Int: UserDefaultsStorable {} extension Double: UserDefaultsStorable {} extension Float: UserDefaultsStorable {} extension Date: UserDefaultsStorable {} extension Data: UserDefaultsStorable {} extension Array: UserDefaultsStorable where Element: UserDefaultsStorable {} extension Dictionary: UserDefaultsStorable where Key == String, Value: UserDefaultsStorable {} /// `Encodable` mapping for storage public extension Encodable { func mapForStorage() -\u003e Any? { do { return try JSONEncoder().encode(self) } catch { print(\"Couldn't encode \\(self)\", error) return nil } } } /// Simple type opening using a static function to allow JSON decoding with erased types conforming to `Decodable` protocol fileprivate extension Decodable { // Useful trick from https://stackoverflow.com/questions/54963038/codable-conformance-with-erased-types static func openedJSONDecode(using decoder: JSONDecoder, from data: Data) throws -\u003e Self { return try decoder.decode(self, from: data) } } /// `Decodable` mapping for reading from storage public extension Decodable { static func mapOutOfStorage(_ value: Any?) -\u003e Self? { guard let data = value as? Data else { return nil } do { return try Self.openedJSONDecode(using: JSONDecoder(), from: data) } catch { print(\"Couldn't decode \\(String(describing: value))\", error) // Very opinionated choice to almost ignore thrown errors return nil } } } @propertyWrapper public class UserDefaultsBacked\u003cValue\u003e { private let key: String private let storage: UserDefaults private let defaultValue: Value private var storingMapper: (Value) -\u003e Any? private var storeReadingMapper: (Any?) -\u003e Value? private init(wrappedValue value: Value, _ key: String, storage: UserDefaults, storingMapper: @escaping StoringMapper\u003cValue\u003e, storeReadingMapper: @escaping StoreReadingMapper\u003cValue\u003e) { defaultValue = value self.key = key self.storage = storage self.storingMapper = storingMapper self.storeReadingMapper = storeReadingMapper } public convenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard) where Value: UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, storingMapper: {$0}, storeReadingMapper: { $0 as? Value}) } public convenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value : Codable { self.init(wrappedValue: value, key, storage: storage, storingMapper: Value.mapForStorage, storeReadingMapper: Value.mapOutOfStorage) } public convenience init(wrappedValue value: Value, _ key: String, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value : Codable \u0026 UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, storingMapper: {$0}, storeReadingMapper: {$0 as? Value}) } public var wrappedValue: Value { get { storage.value(forKey: key) as? Value ?? defaultValue} set { storage.setValue(newValue, forKey: key) } } } Fun fact : j‚Äôai retrouv√© le m√™me flag protocol sur un post (je l‚Äôai plus sous la main l√†), puis vu des impl√©mentations proches pour les Codable, mais tout √ßa bien s√ªr apr√®s avoir r√©invent√© la roue. Et m√™me si on dit souvent √ßa p√©jorativement, dans une d√©marche d‚Äôapprentissage √ßa a tout son sens de regarder les solutions seulement ensuite. Et en plus c‚Äô√©tait vachement moins bien fait, genre l√† pas de type checking, aucune cohabitation entre les Codable et les types natifs‚Ä¶ Nan mais jvous jure‚Ä¶\nEt puis de toute fa√ßon je voulais aussi m‚Äôoccuper de faire ‚Ä¶\nUn publisher un peu custom Lorsqu‚Äôon utilise SwiftUI et Combine simplement, on va naturellement devoir taper des expression comme $myState ou $myObject.prop. Une fois pass√©e mon aversion forte pour le PHP, j‚Äôai creus√© rapidement pour constater que ce n‚Äô√©tait qu‚Äôune syntaxe un peu flippante pour acc√©der √† la valeur projet√©e d‚Äôune wrapped property.\nProjected value ? En bref, n‚Äôimporte quel property wrapper peut d√©clarer une var projectedValue: SomeType {...} dont le type n‚Äôest pas n√©cessairement le m√™me que celui de sa wrappedValue. Et cette projectedValue est accessible gr√¢ce au dollar am√©ricain (comme tellement de choses).\n@propertyWrapper public class Print\u003cValue\u003e { private var val: Value public init(wrappedValue value: Value) { val = value } public var wrappedValue: Value { set { print(\"Setting '\\(val)'\") val = newValue } get { print(\"Returning '\\(val)'\") return val } } public var projectedValue: Int { print(\"42\") return 8 } } @Print var myString: String = \"5\" myString = \"40\" print(\"Coucou \\($myString)\") printera donc\n\u003e Setting '40' \u003e 42 \u003e Coucou 8 Aaah, je pense que j‚Äôai fait le pire exemple qui soit, ‚Äúservice !‚Äù comme on dit dans l‚Äôest.\nBref, ce $ n‚Äôa en th√©orie pas forc√©ment grand chose √† voir avec Combine except√© qu‚Äôon l‚Äôy utilise en permanence.\nQuelques notions de Combine Typiquement, le property wrapper Published a pour type projet√© la struct Published\u003cValue\u003e.Publisher (doc) qui respecte notamment le protocole Publisher (et bien plus, doc), et peut donc envoyer des Value √† des Subscriber.\nDonc quand j‚Äôacc√®de √† un @Published var myString: String via $myString j‚Äôobtiens en gros une propri√©t√© dont je peux √©couter les valeurs successives.\nEt quand je fais du SwiftUI ainsi : .sheet(isPresented: $vm.router.showSheet, ...), je passe donc un Publisher √† la fonction sheet qui se fera un plaisir d‚Äô√©couter si on doit o√π non pr√©senter cette sheet.\nRappel : lorsqu‚Äôon utilise sink pour √©couter les valeurs d‚Äôune var @Published via son Publisher, on re√ßoit la nouvelle valeur alors que la wrappedValue est encore l‚Äôancienne valeur. Et je voudrais contourner √ßa dans certains cas (voir mon post pr√©c√©dent).\nMaintenant, ce qui m‚Äôint√©resserait ce serait d‚Äôavoir √ßa, un Publisher que je pourrais contr√¥ler finement pour lui envoyer des valeurs. Eh bien Combine nous fournit gracieusement le protocole Subject qui h√©rite de Publisher et qui pr√©sente de surcroit une fonction send(_:) permettant d‚Äôenvoyer des valeurs √† publier. Ses impl√©mentations sont :\n CurrentValueSubject qui d√©tient une valeur courante PassthroughSubject qui au contraire ne retient rien  On devrait s‚Äôen sortir avec √ßa !\nDidSet Publisher property wrapper Pour reproduire le comportement de @Published on pourrait √©crire comme √ßa comme √ßa.\n@propertyWrapper public class BasicPublished\u003cValue\u003e { private let subject: CurrentValueSubject\u003cValue, Never\u003e public init(wrappedValue value: Value) { subject = CurrentValueSubject(value) wrappedValue = value } public var wrappedValue: Value { set { subject.send(newValue) } get { subject.value } } public var projectedValue: CurrentValueSubject\u003cValue, Never\u003e { get { subject } } } Le probl√®me √©tant que lorsque le send va provoquer l‚Äôex√©cution de toutes les closures des subscribers, subject.value aura toujours l‚Äôancienne valeur.\nAssez simple du coup d‚Äôy rem√©dier :\n@propertyWrapper public class DidSetPublished\u003cValue\u003e { private var val: Value private let subject: CurrentValueSubject\u003cValue, Never\u003e public init(wrappedValue value: Value) { val = value subject = CurrentValueSubject(value) wrappedValue = value } public var wrappedValue: Value { set { val = newValue subject.send(val) } get { subject.value } } public var projectedValue: CurrentValueSubject\u003cValue, Never\u003e { get { subject } } } (je crois que cette impl√©mentation vient de l√†, et je crois aussi qu‚Äôil serait plus pertinent d‚Äôutiliser PassthroughSubject a priori)\nTout ensemble Vous le saviez, mon but ultime √©tait ~la conqu√™te de la Su√®de en lama~ de combiner tout √ßa. Pas juste pour le fun, mais parce que dans mon archi, √† un moment, j‚Äôavais besoin d‚Äôune propri√©t√© Codable (un enum) stock√©e dans les UserDefaults et qui ne publierait son changement de valeur qu‚Äôapr√®s l‚Äôavoir affect√© √† sa wrappedValue.\nEt puis d‚Äôautres besoins avec des variations : pas de stockage mais publication apr√®s affectation, stockage natif mais publication avant affectation‚Ä¶\nJ‚Äôaurais bien pu contourner tout √ßa, ou encore essayer de faire fonctionner des wrappers imbriqu√©s, mais je voulais me frotter √† cette impl√©mentation sp√©cifique.\nEt voil√†, je vous colle juste l‚Äôensemble l√† dessous, chaque d√©tail √©tant expliqu√© dans les parties pr√©c√©dente (enfin faut savoir quelques trucs en amont quand m√™me, oui).\nN‚Äôoubliez pas que la perf n‚Äôest pas l‚Äôobjectif de ce wrapper (du tout).\nJe vous sugg√®re d‚Äôailleurs de jeter un oeil √† l‚Äôimpl√©mentation de Published chez OpenCombine, qui est particuli√®rement √©l√©gante (ya un enum \u003c3).\n// // SmartPublished.swift // attestation // // Created by Pierre Mardon on 01/01/1970. Trust me. // import Foundation import Combine /// We need functions to map values before storing them to user defaults fileprivate typealias StoringMapper\u003cValue\u003e = (Value) -\u003e Any? /// We need functions to map values read from user defaults storage to an expected type fileprivate typealias StoreReadingMapper\u003cValue\u003e = (Any?) -\u003e Value? /// Any type implementing this protocol can be stored natively in UserDefaults public protocol UserDefaultsStorable {} /** Declare proper flag protocol conformance for all types natively compatible with UserDefaults storage */ extension String : UserDefaultsStorable {} extension Int: UserDefaultsStorable {} extension Double: UserDefaultsStorable {} extension Float: UserDefaultsStorable {} extension Date: UserDefaultsStorable {} extension Data: UserDefaultsStorable {} extension Array: UserDefaultsStorable where Element: UserDefaultsStorable {} extension Dictionary: UserDefaultsStorable where Key == String, Value: UserDefaultsStorable {} /// `Encodable` mapping for storage public extension Encodable { func mapForStorage() -\u003e Any? { do { return try JSONEncoder().encode(self) } catch { print(\"Couldn't encode \\(self)\", error) return nil } } } /// Simple type opening using a static function to allow JSON decoding with erased types conforming to `Decodable` protocol fileprivate extension Decodable { // Useful trick from https://stackoverflow.com/questions/54963038/codable-conformance-with-erased-types static func openedJSONDecode(using decoder: JSONDecoder, from data: Data) throws -\u003e Self { return try decoder.decode(self, from: data) } } /// `Decodable` mapping for reading from storage public extension Decodable { static func mapOutOfStorage(_ value: Any?) -\u003e Self? { guard let data = value as? Data else { return nil } do { return try Self.openedJSONDecode(using: JSONDecoder(), from: data) } catch { print(\"Couldn't decode \\(String(describing: value))\", error) // Very opinionated choice to almost ignore thrown errors return nil } } } /** Property wrapper that provides some common use cases options. Do NOT use for heavy performance demanding components. - `UserDefaults` storage is activated when a `key` is provided for all natively handled types and `Codable` ones - option `sendAfterStore` makes the subject send the value only after it has effectively been affected to the property itself: WARNING this is not recommended for UI bindings. Disabled by default. Usage: \\``` @SmartPublished(\"someKey\") var myProp = \"Bonjoir !\" \\``` The string property will be backed in UserDefaults.standard for the key \"someKey\". It will be effectively stored only if the value of the var is affected after its initialization, until then UserDefaults entry will stay untouched. The initial value of the property will be `\"Bonjoir !\"` if there's not value in the store. \\``` @SmartPublished(\"myCodableValueUserDefaultsKey\") var myProp = someValueOfCodableType \\``` The codables are stored the same way except they are JSON encoded if they're not natively handled by UserDefaults. \\``` @SmartPublished(sendAfterStore = true) var myProp = 8 $myProp.sink { print(\"property: \\(myProp), received: \\($0)\") } myProp = 1 \\``` Will print `property: 1, received: 1`, while with `@Published` or `sendAfterStore = false` it would be `property: 8, received: 1`. It is not recommended to use this `sendAfterStore = true` for UI-bound properties. \\``` @SmartPublished \\``` Why would you do that, just use `@Published` then! */ @propertyWrapper public class SmartPublished\u003cValue\u003e { private let key: String? private let storage: UserDefaults private let sendAfterStore: Bool private let subject: CurrentValueSubject\u003cValue, Never\u003e private var val: Value private var storingMapper: (Value) -\u003e Any? private var storeReadingMapper: (Any?) -\u003e Value? private init(wrappedValue value: Value, _ key: String? , storage: UserDefaults, sendAfterStore: Bool, storingMapper: @escaping StoringMapper\u003cValue\u003e, storeReadingMapper: @escaping StoreReadingMapper\u003cValue\u003e) { var initValue = value if let key = key, let storedValue = storeReadingMapper(storage.object(forKey: key)) { initValue = storedValue } val = initValue subject = CurrentValueSubject(initValue) self.key = key self.storage = storage self.sendAfterStore = sendAfterStore self.storingMapper = storingMapper self.storeReadingMapper = storeReadingMapper subject.send(val) } public convenience init(wrappedValue value: Value, _ key: String? = nil, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value: UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, sendAfterStore: sendAfterStore, storingMapper: {$0}, storeReadingMapper: { $0 as? Value}) } public convenience init(wrappedValue value: Value, _ key: String?, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value : Codable { self.init(wrappedValue: value, key, storage: storage, sendAfterStore: sendAfterStore, storingMapper: {$0.mapForStorage()}, storeReadingMapper: Value.mapOutOfStorage) } public convenience init(wrappedValue value: Value, _ key: String?, storage: UserDefaults = .standard, sendAfterStore: Bool = false) where Value : Codable \u0026 UserDefaultsStorable { self.init(wrappedValue: value, key, storage: storage, sendAfterStore: sendAfterStore, storingMapper: {$0}, storeReadingMapper: { $0 as? Value}) } public convenience init(wrappedValue value: Value, sendAfterStore: Bool = false) { self.init(wrappedValue: value, nil, storage: .standard, sendAfterStore: sendAfterStore, storingMapper: {$0}, storeReadingMapper: {$0 as? Value}) } public var wrappedValue: Value { set { if sendAfterStore { subject.send(newValue) } if let key = self.key { storage.setValue(storingMapper(newValue), forKey: key) } else { val = newValue } if !sendAfterStore { subject.send(newValue) } } get { if let key = self.key { return storeReadingMapper(storage.value(forKey: key)) ?? val } return val } } public var projectedValue: CurrentValueSubject\u003cValue, Never\u003e { get { subject } } } N‚Äôh√©sitez pas √† me contacter pour toute remarque, insulte ou √©loge, mon email est dans le footer ;)\n","description":"","tags":["iOS","Combine","SwiftUI"],"title":"SwiftUI \u0026 Combine Feedback #2 : property wrapper pour UserDefaults et @Published","uri":"/posts/swiftui_combine2/"},{"categories":["Application mobile"],"content":"Apr√®s mon premier petit TP autour de SwiftUI et Combine pour g√©n√©rer mes attestations de d√©placement ~√† la barbe de la mar√©chauss√©e~ √† la vol√©e voire en retard, j‚Äôai profit√© de l‚Äôadaptation au second format d‚Äôattestation pour faire des explorations un peu plus pouss√©es de mon architecture autour de Combine.\nJ‚Äôen sors une petite liste de consid√©rations techniques que j‚Äôesp√®re d‚Äôint√©r√™t, et voici les premi√®res !\nArchitecture: MVVM+ Pour une petite app comme celle-ci, je m‚Äôautorise des entorses √† nombre de principes stricts overkill que je n‚Äôestime pas pertinents ici, avec des gains principalement en concision et lisibilit√©. Le MVVM est tout √† fait indiqu√© pour un cloisonnement minimal, et en l‚Äôoccurence √ßa ressemblait √† √ßa\nAvec des injection par construction et donc cette instanciation initiale :\nlet store = Store(context: moContext) let model = MainViewModel(store: store, router: Router()) return MainView(model: model) On peut remarquer le petit Router qui s‚Äôest av√©r√© fort utile pour √©viter trop de plomberie. Son r√¥le est juste de publier des propri√©t√©s destin√©es √† contr√¥ler et rendre compte de la navigation. Il ne fait donc clairement pas partie du mod√®le ni des vues, et j‚Äôai du mal √† le consid√©rer comme un mod√®le de vue √©tant donn√©e sa nature transverse.\nTant qu‚Äôil ne d√©passe pas ce r√¥le de navigation, ne stocke qu‚Äôun minimum de donn√©es transitoires au besoin (immuables de pr√©f√©rence, la struct d‚Äôune personne √† √©diter par exemple), √ßa reste tr√®s lisible et on √©vite les cha√Ænages de @Published orthodoxes.\nenum ActiveSheet { case attestationPresentation(person: PersonStruct), addPerson, edit(person: PersonStruct) } enum ActiveAlert { case confirmAttestation, detail(reason: Reason) } class Router: ObservableObject { @Published var showSheet = false @Published var showAlert = false private(set) var activeSheet = ActiveSheet.addPerson private(set) var activeAlert = ActiveAlert.confirmAttestation func showAttestationCreationAlert() { activeAlert = .confirmAttestation showAlert = true } func startAddPerson() { activeSheet = .addPerson showSheet = true } func startEdit(person: PersonStruct) { activeSheet = .edit(person: person) showSheet = true } func showReasonDetail(_ reason: Reason) { activeAlert = .detail(reason: reason) showAlert = true } func showAttestationView(person: PersonStruct) { activeSheet = .attestationPresentation(person: person) showSheet = true } func closeSheet() { showSheet = false } } Plut√¥t concis, √ßa vaut clairement le coup plut√¥t que de perdre ces quelques variables dans des chemins trop tortueux.\nTous mes proches le savent, les enums Swift c‚Äôest ma grande passion. Et ceux du petit routeur ci-dessus me permettent de faire des fonctions SwiftUI bien compactes :\nfunc alert() -\u003e Alert { switch vm.router.activeAlert { case .confirmAttestation: return Alert(title: coldFeetTitle, message: coldFeetMessage, primaryButton: .default(Text(\"Je certifie\")) { vm.generateNewAttestation() }, secondaryButton: .cancel(Text(\"Annuler\"))) case .detail(reason: let reason): return Alert(title: Text(reason.niceString), message: Text(reason.detail), dismissButton: .default(Text(\"Ok\"))) } } func sheet() -\u003e AnyView { switch vm.router.activeSheet { case .attestationPresentation(let person): return AnyView(AttestationView(vm: vm.attestationViewModel(person: person))) case .addPerson: return AnyView(AddOrEditPersonSheet(vm: vm.addPersonViewModel)) case .edit(let person): return AnyView(AddOrEditPersonSheet(vm: vm.editPersonViewModel(person: person))) } } Et enfin, le body de ma View principale sera tr√®s concis :\nvar body: some View { NavigationView { VStack(alignment: .center, spacing: 5) { MainListsView(model: vm.mainListsViewModel).environment(\\.editMode, $editMode) BottomMenu(model: vm.bottomMenuViewModel) } .sheet(isPresented: $vm.router.showSheet, onDismiss: { vm.checkShouldShowPinnedAttestation() }, content: sheet) .navigationBarTitle(\"\", displayMode: .inline) .navigationBarItems(leading: navigationBarLeadingItem, trailing: EditButton(editMode: $editMode)) } .alert(isPresented: $vm.router.showAlert, content: alert) } (on peut comprendre d‚Äôailleurs pourquoi je s√©pare le showSheet et showAlert des enums, au lieu de d√©clarer des .none)\nLa vue principale est la principale consommatrice du routeur, cependant de multiples vues viennent agir dessus.\nEvidemment, cette architecture est adapt√©e √† ce projet particulier, ne cherchez pas √† reproduire √ßa √† la maison.\nLes petits trucs p√©nibles Type erasure Ci-dessus, vous pouvez voir que j‚Äôutilise AnyView(...) pour renvoyer un type consistant de View. Pour tous ceux qui ont jou√© un peu en profondeur avec les protocoles et g√©n√©riques en Swift, on atteint vite des obstacles myst√©rieux particuli√®rement brainboiling.\nHeureusement on observe un effort de type erasure dans les biblioth√®ques syst√®me avec ces AnyView, AnyCancellable‚Ä¶\nAinsi que de nouveaux mots cl√© myst√©rieux comme some qui est la r√©ponse directe √† la sentence :\n Protocols ‚ÄòWouldBeSoNice‚Äô can only be used as a generic constraint because it has Self or associated type requirements\n Si √ßa vous int√©resse je vous conseille ce petit article.\nCeci-dit, m√™me si √ßa dispara√Æt vite, je pense que c‚Äôest un frein assez consid√©rable notamment pour des d√©butants.\nObserver des objets imbriqu√©s Un ViewModel en mode Combine doit avoir cette allure :\nclass MyViewModel : ObservableObject { @Published var someProperty = \"Coucou copaing !\" } Le wrapper @Published est tout √† fait adapt√©e aux structs puisque toute mutation d‚Äôune struct est un changement de valeur. Mais les classes si elles sont faites pour √™tre mut√©es ne remonteront point l‚Äô√©v√®nement au wrapper.\nOr pour observer une propri√©t√© imbriqu√©e au deuxi√®me niveau dans SwiftUI, comme .sheet(isPresented: $vm.router.showSheet) {‚Ä¶}, on peut essayer :\n d‚Äôobserver le routeur qui serait une struct et de prendre sa valeur showSheet avec le routeur en ObservableObject, observer directement showSheet  Eh bien aucune des deux options ne fonctionne directement depuis une vue SwiftUI. Ce petit $ qui d√©signe la projectedValue d‚Äôune propri√©t√© encapsul√©e par un @Published ou un @State n‚Äôest pas magique, et √ßa ne fonctionne qu‚Äôau premier niveau, c‚Äôest √† dire un @Published propri√©t√© d‚Äôun ObservableObject.\nEt la feinte officielle n‚Äôest pas bien glorieuse :\nclass MyViewModel : ObservableObject { @Published var router = Router private var cancellables = Set\u003cAnyCancellable\u003e() init(router: Router) { self.router = router router.objectWillChange.sink { [weak self] _ in self?.objectWillChange.send() }.store(in: \u0026cancellables) } deinit { cancellables.forEach({ $0.cancel() }) } } Il-y-a des variantes plus concises au prix de sacrifices discutables, mais voil√† le principe. A chaque fois que le routeur va changer, on va propager l‚Äô√©v√®nement pour indiquer √† l‚ÄôUI de se rafra√Æchir. C‚Äôest un peu large, un peu ‚ÄúMario fait du Combine‚Äù, mais ne soyons pas obtus, si √ßa roule apr√®s tout‚Ä¶\nUne bonne alternative est de mettre tout √ßa √† plat dans la vue :\nstruct MyView: View { @ObservedObject private var vm: MainViewModel var body: some View {...} } deviendrait\nstruct MyView: View { @ObservedObject private var vm: MyViewModel @ObservedObject private var router: Router var body: some View {...} } C‚Äôest plus √©l√©gant je trouve, mais imaginons que j‚Äôai 8 entit√©s un peu complexes √† embarquer dans mon VM, √ßa commence alors √† foisonner plus que de raison.\nAutre point en passant, impossible de s√©curiser l‚Äôinstance embarqu√©e du routeur dans le view-model avec un private(set) modifier dans la premi√®re version. C‚Äôest de l‚Äôordre du TOC - c‚Äôest bien d‚Äôen √™tre conscient - mais √ßa me g√®ne üòÖ\nPropager des @Published, Model -\u003e VM -\u003e View class Store : ObservableObject { @Published private(set) var someUrl: URL? } class MyViewModel : ObservableObject { @Published private(set) var someUrl: URL? init(store: Store) { store.$someUrl.assign(to: \u0026$someUrl) } } Mais c‚Äôest tr√®s raisonnable, super ! Oui mais iOS14+ seulement.\nEt voici la version iOS 13 :\nclass Store : ObservableObject { @Published private(set) var someUrl: URL? } class MyViewModel : ObservableObject { @Published private(set) var someUrl: URL? private var cancellables = Set\u003cAnyCancellable\u003e() init(store: Store) { store.$someUrl.sink { [weak self] url in self?.someUrl = url }.store(in: \u0026cancellables) } deinit { cancellables.forEach({ $0.cancel() }) } } * whip sound *\nPas mal hein ?\n* whip sound *\nSink twice silence g√©nant\nQuand on observe un sujet avec sink, sachez que la valeur qui vous est pass√©e en closure est celle qui va √™tre attribu√©e, comme lorsqu‚Äôon utilise willSet sur une propri√©t√© (quelques d√©tails ici).\nPas de probl√®me pour l‚Äôupdate d‚ÄôUI, c‚Äôest fait pour. Mais pour les autres besoins, comme par exemple quand on a des m√©canismes complexes interm√©diaires qui ne se r√©sument pas √† fusionner deux valeurs publi√©es, la meilleure chose √† faire est encore de cr√©er son publisher.\nEt m√™me si j‚Äôaurais encore beaucoup √† dire autour de ce sujet, je r√©serve √† un futur article une petite contribution autour de ce sujet, des property wrappers et consorts.\nN‚Äôh√©sitez pas √† m‚Äô√©crire si vous avez un avis quelconque sur ce que j‚Äôai √©crit, mon email est (?) dans le footer ;)\n","description":"","tags":["iOS","Combine","SwiftUI"],"title":"SwiftUI \u0026 Combine Feedback #1 : architecture et grains de sable","uri":"/posts/swiftui_combine1/"},{"categories":["Application mobile"],"content":"Il m‚Äôest arriv√© plusieurs fois d‚Äôoublier mon attestation de sortie (c‚Äôest mal), de la g√©n√©rer au volant en panique (c‚Äôest tr√®s mal), de prendre du retard en tapant le formulaire avant de partir‚Ä¶ Loin de moi l‚Äôid√©e de d√©battre du bien-fond√© du confinement et de ses modalit√©s, cependant j‚Äô√©tais confront√© √† un inconfort mineur. Et comme tout bon ing√©, j‚Äôai cherch√© et √©valu√© des solutions compl√®tement superflues - toutefois avec un indiscutable s√©rieux et un professionnalisme in√©branlable.\nLa voie des anciens Imprimer des attestations pr√©remplies et ne laisser que le motif, la date, l‚Äôheure et la signature √† remplir.\nOui √ßa marche, mais la mat√©rialisation est une contrainte forte. Si on oublie de remplir son attestation (c‚Äôest mal) et qu‚Äôon prend la voiture on n‚Äôa pas de moyen de g√©rer la situation sans un 180¬∞ bien crissant (ce qui est certes classe mais dangereux).\nOn me dit dans l‚Äôoreillette qu‚Äôon peut tout √† fait √©crire une attestation √† la main sur papier libre‚Ä¶ Oui mais bon, change pas de sujet, j‚Äôai pas de stylo ni de papier sur moi, voil√†, et puis niveau ergonomie, c‚Äôest so les mill√©naires pass√©s l‚Äô√©criture‚Ä¶\nLa voie officielle #1 (web) J‚Äôai essay√© de faire avec la page web gouvernementale. Et franchement, c‚Äôest correct sur ordinateur avec le bon √©quipement logiciel. J‚Äôutilise personnellement un navigateur Chromium avec le plugin de mon gestionnaire de mots de passe Dashlane. Le seul inconfort √©vident est la lecture des motifs du d√©placement. J‚Äôai commenc√© √† faire un petit plugin Chrome pour retravailler √ßa avant de me raviser rapidement : les plugins ne fonctionnent pas sur les navigateurs Chromium iOS et la g√©n√©ration sur portable est bien plus pratique.\nLa voie officielle #2 (TousAntiCovid) On monte en qualit√© avec le g√©n√©rateur int√©gr√© √† l‚Äôapplication TousAntiCovid. Il est possible de faire retenir mes coordonn√©es par l‚Äôappli et les motifs ont un titre en gras qui permet d‚Äôy voir un peu plus clair. Cependant je ne suis pas int√©ress√© par la fonctionnalit√© de tra√ßage de cette application. Donc je n‚Äôai pas appr√©ci√© quand j‚Äôai d√ª imp√©rativement autoriser l‚Äôapp √† utiliser le bluetooth √† la premi√®re ouverture. Et puis en regardant √ßa, je commen√ßais √† avoir ma petite id√©e de l‚Äôappli id√©ale donc toutes les petites frictions du parcours pour g√©n√©rer mon autorisation me faisaient tiquer. Ca fait quand m√™me pas mal d‚Äô√©tapes apr√®s ouverture de l‚Äôapplication :\n scroll tout en bas tap sur Attestation de d√©placement tap sur Nouvelle attestation entrer mes donn√©es - ok √ßa s‚Äôenregistre on ne le compte pas tap (optionnel) sur l‚Äôheure pour r√©gler l‚Äôheure de ma sortie - je n‚Äôai jamais touch√© √† la date jusque l√† tap pour choisir le motif de d√©placement (qui ne s‚Äôenregistre pas) sur mon iPhone, il faut 3 hauteurs d‚Äô√©cran pour lire int√©gralement la liste des motifs, on ajoute donc souvent un scroll ou deux tap sur le motif tap sur G√©n√©rer alerte de confirmation : tap sur Je certifie  Donc dans le cas id√©al (je pars maintenant, c‚Äôest bien moi qui g√®n√®re l‚Äôattestation et je suis la derni√®re personne √† avoir utilis√© le g√©n√©rateur sur cet appareil, et mon motif est mon caract√®re laborieux) j‚Äôai donc 7 actions avant d‚Äôobtenir le QR Code tant convoit√©. C‚Äôest beaucoup.\nLa voie des ptits malins (app iOS Raccourcis) Certaines bo√Ætes comme Luko ou Newzik vous proposent de g√©n√©rer un lien qui contient vos donn√©es, et qui m√®ne √† un g√©n√©rateur automatique qui affiche l‚Äôattestation g√©n√©r√©e avec l‚Äôheure de sortie actuelle.\nL‚Äôid√©e est notamment d‚Äôutiliser un raccourci d√©clench√© par Siri par exemple pour commander son attestation √† la voix ou encore la faire ouvrir automatiquement d√®s qu‚Äôon quitte son domicile. On n‚Äôest pas loin de la solution id√©ale, seulement je ne peux pas g√©n√©rer une attestation √† la bourre.\nCeci-dit, ce lien est un bon exemple de ce qu‚Äôon peut faire rapidement pour se faciliter la vie. Quelques bookmarks, un peu de configuration et pour les gens pas trop technophobes on s‚Äôen sort.\nL‚Äôapp de mes r√™ves Cahier des charges L‚Äôapp de mes r√™ves\n dans le meilleur des cas, n√©cessite une seule action pour g√©n√©rer une attestation si le motif change, une √† deux actions suppl√©mentaires sont tol√©rables. demande le plus rarement possible des actions suppl√©mentaires. permet √† ma compagne de faire son attestation sur mon t√©l√©phone sans effacer mes donn√©es pr√©remplies g√®re tr√®s efficacement mon cas pathologique d‚Äôoubli. Elle doit donc me permettre de g√©n√©rer mon attestation lorsque je me rends compte apr√®s 20 minutes de trajet que j‚Äôai oubli√© mon attestation : pour √™tre dans les clous, mon heure de sortie doit alors √™tre 20 minutes dans le pass√© n‚Äôembarque aucune autre fonctionnalit√© non souhait√©e n‚Äôenvoie aucune donn√©e √† qui que ce soit (pas de tracking publicitaire ou autre) n‚Äôutilise aucune biblioth√®que tierce non ma√Ætris√©e √† 100%  Je me suis auto-d√©fi√©, et au bout d‚Äôune petite journ√©e de d√©veloppement j‚Äôavais un prototype fonctionnel, ce qui m‚Äôa encourag√© √† continuer. Au bout de trois jours de d√©veloppement j‚Äôavais une app pr√©sentable, les aspects l√©gaux √©taient confirm√©s, et la plupart des raffinements majeurs √©taient impl√©ment√©s.\nR√©alisation ! Je suis bien content d‚Äôannoncer que j‚Äôai respect√© *presque* tous les points de l‚Äôapp de mes r√™ves. Seule entorse, comme il faut quand m√™me √™tre un peu s√©rieux, j‚Äôai ajout√© une confirmation de v√©racit√© des donn√©es √† la g√©n√©ration de l‚Äôattestation, on a donc deux actions pour g√©n√©rer l‚Äôattestation.\nTout comme pour la solution de g√©n√©ration par liens, j‚Äôai r√©cup√©r√© le code publi√© par le minist√®re de l‚Äôint√©rieur pour g√©n√©rer les PDFs en inspectant son int√©gralit√©, en extrayant uniquement les parties n√©cessaires, puis en le modifiant pour son int√©gration dans l‚Äôapp.\nJe ne vais pas vous cacher que je n‚Äôaurais pas fait cette application juste pour me faciliter les sorties. Je voulais √©galement exp√©rimenter SwiftUI, la biblioth√®que d√©clarative d‚Äôinterface utilisateur d‚ÄôApple qui me tend les bras depuis plusieurs ann√©es, et c‚Äô√©tait une bonne occasion.\nEt voici le r√©sultat :\nVue principale Ici on peut :\n ajouter / supprimer / r√©ordonner les personnes s√©lectionner un ou plusieurs motifs de sortie s√©lectionner la date de sortie en temps relatif par rapport √† l‚Äôheure actuelle : les boutons du Stepper (+ / -) ajoutent ou retirent 10 minutes et surtout aller vers l‚Äôattestation !  Vue d‚Äô√©dition de personne Un simple formulaire tout b√™te :)\nPr√©sentation de l‚Äôattestation Tr√®s simple, on peut juste :\n partager le PDF √©pingler l‚Äôattestation : dans ce cas la pr√©sentation en carte ne se laisse pas fermer comme d‚Äôhabitude par swipe vertical, la croix de fermeture dispara√Æt, et au cas o√π l‚Äôutilisateur ferme l‚Äôapp, l‚Äôattestation sera restaur√©e √† la r√©ouverture  Temps de g√©n√©ration de l‚Äôattestation : 3s Dans mon usage quotidien, avec ma (vraie) identit√© de remplie, je mets environ 3s √† remplir mon attestation entre l‚Äôouverture de l‚Äôapp, le choix ou la v√©rification du motif et le r√©glage ou la v√©rification de l‚Äôheure. Oui je suis lent, mais mon objectif est atteint, je peux sans risque g√©n√©rer mon attestation dans des situation d‚Äôurgence et d‚Äôoubli \\o/\nApp Store ? Eh bien malgr√© ma gestion parano√Øaque des donn√©es utilisateur, il semble que ce ne soit pas suffisant pour Apple qui (je pense) n‚Äôautorise simplement aucune app avec cette fonctionnalit√© sauf celle du gouvernement.\n We found in our review that your app provides services or requires sensitive user information related to the COVID-19 pandemic. Since the COVID-19 pandemic is a public health crisis, services and information related to it are considered to be part of the healthcare industry. In addition, the seller and company names associated with your app are not from a recognized institution, such as a governmental entity, hospital, insurance company, non-governmental organization, or university.\nPer section 5.1.1 (ix) of the App Store Review Guidelines, apps that provide services or collect sensitive user information in highly-regulated fields, such as healthcare, should be submitted by a legal entity that provides these services, and not by an individual developer.\n J‚Äôai √©videmment fait appel mais je ne pense pas qu‚Äôils c√®deront, tant pis, je ne partagerai donc mon app qu‚Äôavec mes proches (du moins ceux qui poss√®dent un iPhone) !\nD√©veloppement : retour d‚ÄôXP SwiftUI + Combine Tout d‚Äôabord SwiftUI est tr√®s agr√©able √† utiliser. On a √©videmment les traditionnelles errances de XCode 12, que ce soit niveau compilation, compl√©tion, aper√ßu de l‚ÄôUI‚Ä¶ Mais il convient de saluer la prouesse qu‚Äôest l‚Äôimpl√©mentation de ce framework, un tr√®s bon exemple de DSL sur Swift, qui s‚Äôy pr√™te particuli√®rement bien.\n1struct AddEditPersonSheet: View { 2 3\t// Local state 4 @State 5 private var tappedOkButton = false 6\t7\t// The ViewModel data and callbacks / Yeah I should have created a struct for this 8 @Binding 9 var editingPerson: EditingPerson 10 let isCreation: Bool 11 var cancelAddPerson: () -\u003e Void 12 var endAddOrEditPerson: () -\u003e Void 13 14\t// No constructor (structs are cool) 15\t16 private var title: String { 17 isCreation ? \"Cr√©er\" : \"Modifier\" 18 } 19 20 private func isEmpty(_ str: String) -\u003e Bool { 21 str.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty 22 } 23 24 var body: some View { 25 NavigationView { 26 Form {ss 27 Section(header: Text(\"Identit√©\")) { 28 if tappedOkButton \u0026\u0026 isEmpty(editingPerson.firstName) { 29 Text(\"Pr√©nom manquant\").foregroundColor(.red) 30 } 31 TextField(\"Pr√©nom\", text: $editingPerson.firstName).textContentType(.givenName) 32 if tappedOkButton \u0026\u0026 isEmpty(editingPerson.lastName) { 33 Text(\"Nom manquant\").foregroundColor(.red) 34 } 35 TextField(\"Nom\", text: $editingPerson.lastName).textContentType(.familyName) 36 } 37 // ... other sections 38 } 39 .navigationBarItems(leading: Button(action: cancelAddPerson) { 40 Text(\"Annuler\") 41 }, trailing: Button(action: { 42 withAnimation { 43 tappedOkButton = true 44 if (editingPerson.isValid) { 45 endAddOrEditPerson() 46 } 47 } 48 }) { 49 Text(\"Enregistrer\") 50 }.disabled(tappedOkButton \u0026\u0026 editingPerson.isValid)) 51 .navigationBarTitle(Text(title), displayMode: .inline) 52 } 53 } 54} Pas de critiques les puristes, j‚Äôai fait du monolingue et du gros inline volontairement.\nD√©veloppement rapide : Gr√¢ce √† cette approche DSL, on se retrouve avec du code √† l‚Äôimbrication proche de l‚ÄôUI, facilement intelligible, avec de tr√®s bons comportements par d√©faut. Comme c‚Äô√©tait mon premier test j‚Äôai forc√©ment un peu ram√©, mais j‚Äôaurais pris bien plus de 3 jours de d√©veloppement pour une petite app compl√®te, fonctionnelle et propre si j‚Äôavais d√ª rapprendre UIKit ou pire : HTML + CSS.\nLe couplage avec Combine permet de s‚Äôengager sur le chemin des state-driven apps. Pour avoir pas mal jou√© avec React + Redux, je ne peux que vous inciter √† adopter ce paradigme. Evidemment, quand on n‚Äôa jamais fait que de la programmation imp√©rative, beaucoup de petites choses peuvent √™tre frustrantes au premier abord. Mais √ßa d√©graisse tellement ! Et pour ceux qui ont d√©j√† eu des interrogations philosophiques sur les architectures logicielles en iOS - entre MVC = Massive View Controller par exemple) et le trop souvent overkill VIPER -, SwiftUI + Combine incitent tr√®s naturellement √† d√©rouler le code en MVVM, apportant enfin une alternative moderne et structurante.\nRIP UIKit ? : Bien s√ªr que non, SwiftUI est principalement une surcouche d‚ÄôUIKit qui a encore de beaux jours devant lui. On peut d‚Äôailleurs palier assez facilement l‚Äôabsence de nombreux composants essentiels de SwiftUI en encapsulant une UIView, comme j‚Äôai d√ª le faire pour le lecteur PDF et la webview qui appelle le code de g√©n√©ration du document PDF.\nC‚Äôest tout, ce fut un bon petit d√©fi sympa et enrichissant !\nJ‚Äôesp√®re avoir l‚Äôoccasion de r√©crire sur Swift qui reste un de mes langages pr√©f√©r√©s, mais pour le moment je replonge dans mes projets TypeScript qui se positionne franchement pas mal non plus et a l‚Äôavantage d‚Äô√™tre largement adopt√© en dehors du petit monde Apple.\n","description":"","tags":["iOS","Combine","SwiftUI","confinement","covid"],"title":"Attestation 2s iOS","uri":"/posts/attestation-ios/"}]
