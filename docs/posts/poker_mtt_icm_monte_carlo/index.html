<!DOCTYPE html>
<html lang="fr">
    <head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.80.0" /><meta name="theme-color" content="#fff" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>Poker : MTT et ICM - Méthode de Monte-Carlo | Pitt&#39;s Craft</title>

    <link rel="stylesheet" href="/css/meme.min.f9894a4a4e2059037165836b72caba3584b7eddf447230427071d466c3bdd7ab.css"/>

    
    
        <script src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lunr-languages@1.4.0/min/lunr.stemmer.support.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lunr-languages@1.4.0/min/lunr.fr.min.js" defer></script><script src="/js/meme.min.2e8cecdb28365acb51546c474e04cc3d1566d483eb8370d97ec4daebeaec1398.js"></script>

    

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM&#43;Plex&#43;Serif:ital,wght@0,400;0,500;0,700;1,400;1,700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Comfortaa:wght@700&amp;display=swap" media="print" onload="this.media='all'" />
        <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM&#43;Plex&#43;Serif:ital,wght@0,400;0,500;0,700;1,400;1,700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Comfortaa:wght@700&amp;display=swap" /></noscript>

    <meta name="author" content="Pitt" /><meta name="description" content="Un Monaco-Picon s&#39;il vous plaît. En pinte." />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#2a6df4" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="Pitt&#39;s Craft" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="Pitt&#39;s Craft" />
    <meta name="msapplication-starturl" content="../../" />
    <meta name="msapplication-TileColor" content="#fff" />
    <meta name="msapplication-TileImage" content="../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="https://pittscraft.com/posts/poker_mtt_icm_monte_carlo/" />
    

<script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "datePublished": "2021-03-31T08:14:35+01:00",
        "dateModified": "2021-03-31T08:14:35+01:00",
        "url": "https://pittscraft.com/posts/poker_mtt_icm_monte_carlo/",
        "headline": "Poker : MTT et ICM - Méthode de Monte-Carlo",
        "description": "Un Monaco-Picon s'il vous plaît. En pinte.",
        "inLanguage" : "fr",
        "articleSection": "posts",
        "wordCount":  3705 ,
        "image": "https://pittscraft.com/images/apple-touch-icon.png",
        "author": {
            "@type": "Person",
            "email": "pitt@pittscraft.com",
            "image": "https://pittscraft.com/icons/apple-touch-icon.png",
            "url": "https://pittscraft.com/about/",
            "name": "Pitt"
        },
        "publisher": {
            "@type": "Organization",
            "name": "Pitt's Craft",
            "logo": {
                "@type": "ImageObject",
                "url": "https://pittscraft.com/images/apple-touch-icon.png"
            },
            "url": "https://pittscraft.com/"
        },
        "mainEntityOfPage": {
            "@type": "WebSite",
            "@id": "https://pittscraft.com/"
        }
    }
</script>

    

<meta name="twitter:card" content="summary" />

<meta name="twitter:site" content="@Pitt51279043" />
<meta name="twitter:creator" content="@Pitt51279043" />

    



<meta property="og:title" content="Poker : MTT et ICM - Méthode de Monte-Carlo" />
<meta property="og:description" content="Un Monaco-Picon s&#39;il vous plaît. En pinte." />
<meta property="og:url" content="https://pittscraft.com/posts/poker_mtt_icm_monte_carlo/" />
<meta property="og:site_name" content="Pitt&#39;s Craft" />
<meta property="og:locale" content="fr" /><meta property="og:image" content="https://pittscraft.com/images/apple-touch-icon.png" />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2021-03-31T08:14:35&#43;01:00" />
    <meta property="article:modified_time" content="2021-03-31T08:14:35&#43;01:00" />
    
    <meta property="article:section" content="posts" />



    
</head>

    <body>
        <div class="container">
            
    <header class="header">
        
            <div class="header-wrapper">
                <div class="header-inner single">
                    
    <div class="site-brand">
        
            <a href="/" class="brand">Pitt&#39;s Craft</a>
        
    </div>

                    <nav class="nav">
    <ul class="menu" id="menu">
        
            
        
        
        
        
            
                <li class="menu-item"><a href="/posts/"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon archive"><path d="M32 448c0 17.7 14.3 32 32 32h384c17.7 0 32-14.3 32-32V160H32v288zm160-212c0-6.6 5.4-12 12-12h104c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H204c-6.6 0-12-5.4-12-12v-8zM480 32H32C14.3 32 0 46.3 0 64v48c0 8.8 7.2 16 16 16h480c8.8 0 16-7.2 16-16V64c0-17.7-14.3-32-32-32z"/></svg><span class="menu-item-name">Posts</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/categories/"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon th"><path d="M149.333 56v80c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24V56c0-13.255 10.745-24 24-24h101.333c13.255 0 24 10.745 24 24zm181.334 240v-80c0-13.255-10.745-24-24-24H205.333c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256 0 24.001-10.745 24.001-24zm32-240v80c0 13.255 10.745 24 24 24H488c13.255 0 24-10.745 24-24V56c0-13.255-10.745-24-24-24H386.667c-13.255 0-24 10.745-24 24zm-32 80V56c0-13.255-10.745-24-24-24H205.333c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.256 0 24.001-10.745 24.001-24zm-205.334 56H24c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24h101.333c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24zM0 376v80c0 13.255 10.745 24 24 24h101.333c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H24c-13.255 0-24 10.745-24 24zm386.667-56H488c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zm0 160H488c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H386.667c-13.255 0-24 10.745-24 24v80c0 13.255 10.745 24 24 24zM181.333 376v80c0 13.255 10.745 24 24 24h101.333c13.255 0 24-10.745 24-24v-80c0-13.255-10.745-24-24-24H205.333c-13.255 0-24 10.745-24 24z"/></svg><span class="menu-item-name">Categories</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/tags/"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" class="icon tags"><path d="M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"/></svg><span class="menu-item-name">Tags</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/about/"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon user-circle"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6 0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7 0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4 0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9 14.3 0 28-2.7 40.9-6.9 2.3-.7 4.7-1.1 7.1-1.1 42.9 0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"/></svg><span class="menu-item-name">About</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href=""></a>
                </li>
            
        
            
                
            
        
            
                <li class="menu-item search-item">
                        <form id="search" class="search" role="search">
    <label for="search-input"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon search-icon"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></label>
    <input type="search" id="search-input" class="search-input">
</form>

<template id="search-result" hidden>
    <article class="content post">
        <h2 class="post-title"><a class="summary-title-link"></a></h2>
        <summary class="summary"></summary>
        <div class="read-more-container">
            <a class="read-more-link">Lire Plus »</a>
        </div>
    </article>
</template>

                    </li>
                
            
        
    </ul>
</nav>

                    
                </div>
            </div>
            
    <input type="checkbox" id="nav-toggle" aria-hidden="true" />
    <label for="nav-toggle" class="nav-toggle"></label>
    <label for="nav-toggle" class="nav-curtain"></label>


        
    </header>




            
            
    <main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post h-entry" data-small-caps="true" data-align="default" data-type="posts" data-toc-num="true">

            <h1 class="post-title p-name">Poker : MTT et ICM - Méthode de Monte-Carlo</h1>

            

            
                <div class="post-description p-summary">Un Monaco-Picon s&rsquo;il vous plaît. En pinte.</div>
                
            

            
                

<div class="post-meta">
    
        
        <time datetime="2021-03-31T08:14:35&#43;01:00" class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z"/></svg>&nbsp;31.3.2021</time>
    
    
        
        <time datetime="2021-03-31T08:14:35&#43;01:00" class="post-meta-item modified dt-updated"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M400 64h-48V12c0-6.627-5.373-12-12-12h-40c-6.627 0-12 5.373-12 12v52H160V12c0-6.627-5.373-12-12-12h-40c-6.627 0-12 5.373-12 12v52H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm-6 400H54a6 6 0 0 1-6-6V160h352v298a6 6 0 0 1-6 6zm-52.849-200.65L198.842 404.519c-4.705 4.667-12.303 4.637-16.971-.068l-75.091-75.699c-4.667-4.705-4.637-12.303.068-16.971l22.719-22.536c4.705-4.667 12.303-4.637 16.97.069l44.104 44.461 111.072-110.181c4.705-4.667 12.303-4.637 16.971.068l22.536 22.718c4.667 4.705 4.636 12.303-.069 16.97z"/></svg>&nbsp;31.3.2021</time>
    
    
    
        
        
        
            
                <span class="post-meta-item category"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M464 128H272l-54.63-54.63c-6-6-14.14-9.37-22.63-9.37H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V176c0-26.51-21.49-48-48-48zm0 272H48V112h140.12l54.63 54.63c6 6 14.14 9.37 22.63 9.37H464v224z"/></svg>&nbsp;<a href="/categories/game-theory/" class="category-link p-category">Game Theory</a></span>
            
        
    
    
        
        <span class="post-meta-item wordcount"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3 0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9 0l60.1 60.1c18.8 18.7 18.8 49.1 0 67.9zM284.2 99.8L21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3 0-17l-111-111c-4.8-4.7-12.4-4.7-17.1 0zM124.1 339.9c-5.5-5.5-5.5-14.3 0-19.8l154-154c5.5-5.5 14.3-5.5 19.8 0s5.5 14.3 0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8 0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;3705</span>
    
    
        
        <span class="post-meta-item reading-time"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm61.8-104.4l-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;18&nbsp;min.</span>
    
    
    
</div>

            

            <div class="post-body e-content">
              <p><em>Résumé des épisodes précédents:</em></p>
<ul>
<li>En théorie des jeux, <a href="https://pittscraft.com/posts/poker_mtt_icm_question/" target="_blank" rel="noopener">les fonctions d&rsquo;évaluation</a> permettent d&rsquo;évaluer des situations, de les comparer, et donc de faire des choix renseignés</li>
<li>l&rsquo;Independent Chip Model (ICM) est la fonction d&rsquo;évaluation de référence pour les tournois de poker, et on cherche à trouver mieux, notamment pour un grand nombre de joueurs</li>
<li>l&rsquo;ICM est long à calculer pour un grand nombre de joueurs. <a href="https://pittscraft.com/posts/poker_mtt_icm_calcul/" target="_blank" rel="noopener">Après pas mal d&rsquo;optimisations</a>, on a des temps humainement raisonnables pour une vingtaine de joueurs payés maximum. Si on veut utiliser l&rsquo;ICM de manière intensive comme dans une simulation de tournoi, il faudra viser plutôt autour de dix joueurs payés.</li>
</ul>
<p style="text-indent:0"><span class="drop-cap">D</span>u coup©™ peut-on obtenir des valeurs correctes pour un plus grand nombre de joueurs ?</p>
<h2 id="monte-carlo--le-tâtonnement-convergent"><a href="#monte-carlo--le-tâtonnement-convergent" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>Monte-Carlo : le tâtonnement convergent</h2>
<p>Une méthode commune d&rsquo;approximation de valeur est la <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method" target="_blank" rel="noopener">méthode de Monte-Carlo (MC)</a>. On va évaluer différents points d&rsquo;une fonction complexe choisis aléatoirement pour déduire une approximation probabiliste de sa moyenne. En l&rsquo;occurence pour l&rsquo;ICM on peut typiquement essayer de tirer aléatoirement le classement des joueurs selon les hypothèses de l&rsquo;ICM ce qui n&rsquo;est somme-toute pas évident.</p>
<p>Naïvement on devrait tirer le premier joueur classé selon une probabilité proportionnelle à son stack, puis le second parmi les joueurs restants et les stacks restants et ainsi de suite. Autant vous dire qu&rsquo;on ne va pas bien loin avec ça car la complexité est alors assez violente : pour chaque tirage on doit calculer la distribution de probabilité et effectuer un tirage, ce qui au minimum va nous mener sur du <em>O(n<sup>2</sup>)</em> pour un tirage, et il en faut pas mal.</p>
<p>Heureusement des gens ont réfléchi, et notamment le développeur d&rsquo;IA <a href="https://twitter.com/tysenstreib" target="_blank" rel="noopener">Tysen Streib</a> qui a beaucoup contribué à l&rsquo;analyse stratégique au poker (il a co-écrit <em>Kill everyone</em> notamment). Il a donc très justement analysé en 2011 qu&rsquo;il était possible d&rsquo;effectuer un tirage de la sorte en tirant aléatoirement la durée de vie de chaque joueur selon <em>uniform_random[O:1]<sup>1/stack</sup></em>, puis en ordonnant les durées de vie pour obtenir l&rsquo;ordre de classement des joueurs.</p>
<p>Je vous recommande fortement la lecture de <a href="https://forumserver.twoplustwo.com/15/poker-theory/new-algorithm-calculate-icm-large-tournaments-1098489/" target="_blank" rel="noopener">son post original ici</a> et du thread qui suit, où l&rsquo;algorithme tant que les raisons de la convergence sont bien expliqués, <a href="https://forumserver.twoplustwo.com/showpost.php?p=28773129&amp;postcount=17" target="_blank" rel="noopener">à un niveau intuitif</a>, avec <a href="https://forumserver.twoplustwo.com/showpost.php?p=28900308&amp;postcount=27" target="_blank" rel="noopener">une interprétation théorique</a> et même des optimisations.</p>
<h2 id="implémentation"><a href="#implémentation" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>Implémentation</h2>
<p>Les gros points de consommation de CPU sont :</p>
<ul>
<li>le tirage aléatoire</li>
<li>le calcul de puissance</li>
<li>le tri</li>
</ul>
<p>Comme suggéré dans le fil du post, on obtient de meilleures performance en utilisant le logarithme de la formule de tirage, <code>log</code> est strictement croissant donc l&rsquo;ordre reste le même.</p>
<p>Pour le tirage aléatoire, on a besoin d&rsquo;un aléatoire statistique correct mais sans qualité cryptographique particulière. On gagne pas mal en utilisant <a href="http://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/SFMT/index.html" target="_blank" rel="noopener">SFMT</a>, une variante de l&rsquo;algorithme de Mersenne-Twister plus rapide sur les microprocesseurs modernes.</p>
<p>Enfin pour le tri il faut noter que selon la distribution des prix, on peut éventuellement chercher à classer les premiers joueurs pour les places ayant un prix non-nul. Ce n&rsquo;est pas une optimisation systématique mais lorsqu&rsquo;elle est pertinente il serait dommage de l&rsquo;ignorer.</p>
<p>Voici une version directe, sans autre optimisation.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">
<span class="cp">#include</span> <span class="cpf">&#34;monte-carlo-icm.hpp&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sfmt.hpp&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/**
</span><span class="cm">  * Compute a permutation according to the sorting of random values put to the power of given weights.
</span><span class="cm">  * In fact, logarithm is used for performance, and logarithm tables could certainly be used to fasten the
</span><span class="cm">  * computation.
</span><span class="cm">  *
</span><span class="cm">  * @param weights
</span><span class="cm">  * @param destination where the permutation will be written to
</span><span class="cm">  * @param size size of weights and destination array
</span><span class="cm">  * @param dist random distribution
</span><span class="cm">  * @param mt SFMT (fast Mersenne-Twister algorithm)
</span><span class="cm">  */</span>
<span class="kt">void</span> <span class="nf">monteCarloPermutation</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">weights</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">destination</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
                            <span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">dist</span><span class="p">,</span> <span class="n">wtl</span><span class="o">::</span><span class="n">sfmt19937</span> <span class="o">&amp;</span><span class="n">mt</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">draw</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">draw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">log2</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">mt</span><span class="p">))</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">destination</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">destination</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
          <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Reverse order
</span><span class="c1"></span>              <span class="k">return</span> <span class="p">(</span><span class="n">draw</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">draw</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
          <span class="p">}</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm">  * Same as `monteCarloPermutation` except the sorting process stops for performance
</span><span class="cm">  * after the first values are sorted.
</span><span class="cm">  *
</span><span class="cm">  * @param weights
</span><span class="cm">  * @param destination where the permutation will be written to
</span><span class="cm">  * @param size size of weights and destination array
</span><span class="cm">  * @param nbRelevant number of top values that should be strictly sorted. The other ones may not be sorted
</span><span class="cm">  *          according to the random draw.
</span><span class="cm">  * @param dist random distribution
</span><span class="cm">  * @param mt SFMT (fast Mersenne-Twister algorithm)
</span><span class="cm">  */</span>
<span class="kt">void</span> <span class="nf">monteCarloPermutationPartial</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">weights</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">destination</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="kt">int</span> <span class="n">nbRelevant</span><span class="p">,</span>
                                  <span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">dist</span><span class="p">,</span> <span class="n">wtl</span><span class="o">::</span><span class="n">sfmt19937</span> <span class="o">&amp;</span><span class="n">mt</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">draw</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">draw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">log2</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">mt</span><span class="p">))</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">destination</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">partial_sort</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">destination</span> <span class="o">+</span> <span class="n">nbRelevant</span><span class="p">,</span> <span class="n">destination</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
                  <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                      <span class="c1">// Reverse order
</span><span class="c1"></span>                      <span class="k">return</span> <span class="p">(</span><span class="n">draw</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">draw</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
                  <span class="p">}</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">firstZeroPayout</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">payouts</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">payouts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">firstZeroPayout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">firstZeroPayout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">payouts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">firstZeroPayout</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">payouts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">firstZeroPayout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">firstZeroPayout</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm">  * Monte-Carlo ICM Ranking algorithm.
</span><span class="cm">  *
</span><span class="cm">  * @param stacks
</span><span class="cm">  * @param payouts
</span><span class="cm">  * @param trials
</span><span class="cm">  * @param relevantRanksCount
</span><span class="cm">  * @param results array of ICM EV
</span><span class="cm">  */</span>
<span class="kt">void</span> <span class="nf">monteCarloIcm</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">stacks</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">payouts</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">trials</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">int</span> <span class="n">relevantRanksCount</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Algorithm : https://forumserver.twoplustwo.com/15/poker-theory/new-algorithm-calculate-icm-large-tournaments-1098489/
</span><span class="c1"></span>    <span class="c1">// Initialize random distribution
</span><span class="c1"></span>    <span class="c1">// https://stackoverflow.com/questions/19665818/generate-random-numbers-using-c11-random-library
</span><span class="c1"></span>    <span class="c1">// SFMT variant
</span><span class="c1"></span>    <span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
    <span class="n">wtl</span><span class="o">::</span><span class="n">sfmt19937</span> <span class="n">mt</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
    <span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">permutation</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">stacksAvg</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">stacks</span><span class="p">,</span> <span class="n">stacks</span> <span class="o">+</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">nbPlayers</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">weights</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>
    <span class="kt">double</span> <span class="n">contrib</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>
    <span class="c1">// - Normalize stacks (not really necessary but cheap) and invert to weights
</span><span class="c1"></span>    <span class="c1">// - Prepare each trial ranking contribution to the total
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stacksAvg</span> <span class="o">/</span> <span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">contrib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">payouts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">trials</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Partial sort vs sort : interesting only if we have many zero payouts at the end
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">float</span> <span class="n">partialSortThreshold</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="c1">// Magic number &lt;3
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">bool</span> <span class="n">partialSort</span> <span class="o">=</span>
            <span class="n">relevantRanksCount</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span> <span class="n">relevantRanksCount</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">nbPlayers</span> <span class="o">&lt;=</span> <span class="n">partialSortThreshold</span><span class="p">);</span>


    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">trials</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Draw a permutation
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">partialSort</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">monteCarloPermutationPartial</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">permutation</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="n">relevantRanksCount</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">mt</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">monteCarloPermutation</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">permutation</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">mt</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// Cumulate payouts according to the random permutation
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">results</span><span class="p">[</span><span class="n">permutation</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">contrib</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm">  * Vector wrapper of MC ICM
</span><span class="cm">  * @param stacks
</span><span class="cm">  * @param payouts
</span><span class="cm">  * @param trials
</span><span class="cm">  * @return ICM EV
</span><span class="cm">  */</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">monteCarloIcm</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">stacks</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">payouts</span><span class="p">,</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">trials</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">nbPlayers</span> <span class="o">=</span> <span class="n">stacks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">relevantRanksCount</span> <span class="o">=</span> <span class="n">firstZeroPayout</span><span class="p">(</span><span class="n">payouts</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">stacksArray</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>
    <span class="kt">double</span> <span class="n">payoutsArray</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>
    <span class="kt">double</span> <span class="n">resultsArray</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stacksArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">payoutsArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">payouts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">resultsArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">monteCarloIcm</span><span class="p">(</span><span class="n">stacksArray</span><span class="p">,</span> <span class="n">payoutsArray</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="n">trials</span><span class="p">,</span> <span class="n">relevantRanksCount</span><span class="p">,</span> <span class="n">resultsArray</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">resultsArray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">results</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="autres-pistes-doptimisation"><a href="#autres-pistes-doptimisation" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>Autres pistes d&rsquo;optimisation</h2>
<p>Voici quelques optimisations que j&rsquo;imagine pertinentes :</p>
<ul>
<li>l&rsquo;échantillonnage préférentiel : plus d&rsquo;échantillons pour les cas les plus probables. On pourrait par exemple fixer successivement chaque joueur premier du classement, et estimer ce cas avec plus ou moins de précision par exemple avec un nombre d&rsquo;échantillon proportionnel à sa probabilité au carré (la contribution de chaque cas restant proportionnelle au stack du joueur bien sûr). Pourquoi pas aller un ou plusieurs crans plus loin en envisageant toutes les combinaisons des k premiers joueurs.</li>
<li>le <a href="https://fr.wikipedia.org/wiki/M%C3%A9thode_de_quasi-Monte-Carlo" target="_blank" rel="noopener">quasi-Monte-Carlo</a>, une répartition plus homogène peut apporter une convergence plus rapide</li>
<li>pour le tri et pour les très grands nombre de joueurs, comme les payouts sont souvent par palliers, utiliser quand c&rsquo;est pertinent une succession de tris partiels par palier (plus précisément des <a href="https://cs.stackexchange.com/questions/136619/batch-partial-sorting-algorithm" target="_blank" rel="noopener">algorithmes de sélection</a>).</li>
</ul>
<p>Si vous explorez ces optimisations (ou d&rsquo;autres), faites-m&rsquo;en part, je suis curieux !</p>
<h2 id="convergence"><a href="#convergence" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>Convergence</h2>
<p>On sait qu&rsquo;on a une convergence en <em>O(1/sqrt(n))</em> (<em>note : ajouter une extension LateX à mon site builder</em>). Mais ça ne nous dit pas quand il faut arrêter l&rsquo;échantillonnage !
Par le passé j&rsquo;utilisais de petits algos observant la variation sur des lots de puissances de deux d&rsquo;échantillons, ce qui n&rsquo;est pas fiable : on peut avoir une convergence très lente, et un fort ralentissement ne permet pas de conclure en une précision donnée. &ldquo;En pratique, ça marche&rdquo; oui, enfin peut-être, mais ce n&rsquo;est pas forcément beaucoup plus dur d&rsquo;implémenter des garanties statistiques sûres.</p>
<p>Après quelques recherches j&rsquo;ai trouvé une méthode assez générique dans ce (vieux) papier<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">[1]</a></sup>. Le calcul se base sur un plafond en dessous duquel la variance d&rsquo;un échantillon satisfait une garantie statistique : avec une probabilité <code>α</code>, la moyenne de l&rsquo;échantillon est dans l&rsquo;intervalle de confiance de taille <code>d</code> autour de la moyenne à la limite.</p>
<p>J&rsquo;ai donc réorganisé un peu mon code pour l&rsquo;implémenter. Le coût du calcul étant assez élevé, il convient de ne pas l&rsquo;appliquer à chaque étape de l&rsquo;échantillonage, mais plutôt régulièrement, tous les 100 échantillons par exemple. De plus, j&rsquo;ai extrait les définitions du RNG (pour un futur quasi-Monte-Carlo) et du tri (pour un futur tri partiel par palliers) histoire de pouvoir plus facilement implémenter d&rsquo;autres versions de l&rsquo;algorithme - <em>voir le code en fin d&rsquo;article</em>.</p>
<p>Un point important à considérer est que la variance d&rsquo;un calcul d&rsquo;ICM par la méthode de Monte-Carlo dépend fortement de la distribution des stacks des joueurs et de celle des prix. En effet, pour prendre un extrême, si tous les prix sont égaux la variance est simplement nulle. On va évidemment souhaiter éviter le coût de calcul de cette <em>stopping rule</em> si on en opère en nombre, mais il faudra être prudent pour garder des garanties correctes. De plus, la taille <code>d</code> de l&rsquo;intervalle de confiance est liée linéairement aux prix. Si on distribue deux fois plus de prix aux joueurs, pour une même précision relative on devra multiplier <code>d</code> par deux. L&rsquo;idéal est alors d&rsquo;exprimer <code>d</code> en fonction d&rsquo;une grandeur pertinente comme la somme des prix distribués et d&rsquo;en tenir compte lors du traitement d&rsquo;échantillons variés pour au moins connaître la précision des résultats calculés.</p>
<p>Si les échantillons sont assez homogènes, on pourra par exemple faire une petite tambouille comme calculer le nombre d&rsquo;itérations nécessaires sur un petit ensemble de situations extraites du paquet à traiter, prendre le maximum et le multiplier par deux pour traiter tout le paquet (à vue de nez, &ldquo;en pratique, ça marche&rdquo;).</p>
<h2 id="performance"><a href="#performance" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>Performance</h2>
<p>Je me suis intéressé au cas de 50 joueurs, les 40 premiers étant payés. Pour construire la structure de prix, j&rsquo;ai notamment lu <a href="https://www.chrismusco.com/dfsPresentation.pdf" target="_blank" rel="noopener">cette présentation</a> qui m&rsquo;a encouragé à utiliser une <em>power law fall-off</em> (une chute de loi de puissance..?) telle que le joueur au rang <code>i</code> obtienne un prix proportionnel à <code>1 / pow(i, a)</code>. J&rsquo;ai négligé les étapes d&rsquo;humanisation car je suspecte qu&rsquo;au mieux elles font baisser la variance en créant des plateaux. Soyons-donc joyeusement pessimistes !</p>
<p>J&rsquo;ai ensuite pris une distribution de stacks aléatoires selon une loi normale <a href="https://fr.wikipedia.org/wiki/Loi_tronqu%C3%A9e" target="_blank" rel="noopener">tronquée</a>. Je ne pense pas que c&rsquo;est vraiment représentatif d&rsquo;une situation particulière, les distributions de stack sont assez difficiles à modéliser. Enfin pour le moment ça suffira, on cherche juste à connaître la performance de notre algorithme.</p>
<p>Dans ces circonstances, l&rsquo;évaluation de la <em>stopping rule</em> pour une probabilité de <code>0.9</code> avec un intervalle de confiance de taille <code>1</code> (sachant que la somme des prix vaut 1000) me donne de manière assez stable une taille d&rsquo;échantillon de <strong>15500</strong>.</p>
<p>Et une fois débarrassés de cette évaluation, le calcul prend <code>27ms</code> pour une moyenne sur 15500 échantillons. C&rsquo;est très raisonnable en soi, mais si j&rsquo;envisage de simuler quelques milliers de tournois comportant des milliers de mains elles-mêmes incluant plusieurs calculs d&rsquo;ICM, ce ne sera pas suffisant. Damned.</p>
<p>Mais j&rsquo;ai une idée un peu taquine pour résoudre ça&hellip;</p>
<h2 id="next-step"><a href="#next-step" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>Next step</h2>
<p>Tout ça pour&hellip; pour quoi déjà ? Pour défier l&rsquo;ICM, parce qu&rsquo;on se demande s&rsquo;il n&rsquo;y a pas mieux, et sinon pour se convaincre que c&rsquo;est une bonne approximation.</p>
<p>Je pense qu&rsquo;on pourrait déjà aller vers des simulations intéressantes avec un nombre réduit de joueurs pour mettre en évidence certains comportements. Mais je suis sur une bonne lancée, on va pas s&rsquo;arrêter en si bon chemin !</p>
<p>Ce sera donc pour mon prochain article, en attendant n&rsquo;hésitez pas à me contacter pour toute critique ou discussion via mon email en pied de page !</p>
<h2 id="bonus--le-code"><a href="#bonus--le-code" class="anchor-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon anchor-icon"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"/></svg></a>Bonus : le code</h2>
<p>Tout d&rsquo;abord on a besoin d&rsquo;une fonction qui n&rsquo;existe pas dans les bibliothèques standard : <code>norminv</code> qui permet de déterminer pour quelle abscisse on obtient à gauche une certaine fraction de la population d&rsquo;une distribution normale unitaire centrée en 0.</p>
<p>Un certain John D. Cook l&rsquo;a fait pour nous, on va donc utiliser son code.</p>
<p><code>util/math.cpp</code></p>
<p><em>Collez le code de cette page <a href="https://www.johndcook.com/blog/cpp_phi_inverse/" target="_blank" rel="noopener">https://www.johndcook.com/blog/cpp_phi_inverse/</a></em></p>
<p><code>util/math.hpp</code></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#ifndef MTT_EXPERIMENTS_C_MATH_HPP
</span><span class="cp">#define MTT_EXPERIMENTS_C_MATH_HPP
</span><span class="cp"></span><span class="kt">double</span> <span class="nf">NormalCDFInverse</span><span class="p">(</span><span class="kt">double</span> <span class="n">p</span><span class="p">);</span>

<span class="cp">#endif </span><span class="c1">//MTT_EXPERIMENTS_C_MATH_HPP
</span></code></pre></div><p><code>monte-carlo-icm.cpp</code></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&#34;monte-carlo-icm.hpp&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sfmt.hpp&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;util/math.hpp&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">icm</span> <span class="p">{</span>
    <span class="cm">/**
</span><span class="cm">     * The Random Number Generator type : functions denoted by this alias are expected to draw doubles between 0 and 1.
</span><span class="cm">     * Abstracted in order to plug a proper RNG for quasi-Monte-Carlo in the future.
</span><span class="cm">     */</span>
    <span class="k">using</span> <span class="n">RNG</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="cm">/**
</span><span class="cm">     * The sorter functions are expected to sort the indexes of the draw array in reverse order according to the values
</span><span class="cm">     * of the array.
</span><span class="cm">     */</span>
    <span class="k">using</span> <span class="n">Sorter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">draw</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">destination</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="cm">/**
</span><span class="cm">     * Private section
</span><span class="cm">     */</span>
    <span class="k">namespace</span> <span class="p">{</span>
        <span class="cm">/**
</span><span class="cm">         * Compute a permutation according to the sorting of random values put to the power of given weights.
</span><span class="cm">         * In fact, logarithm is used for performance, and logarithm tables could certainly be used to fasten the
</span><span class="cm">         * computation.
</span><span class="cm">         *
</span><span class="cm">         * @param weights
</span><span class="cm">         * @param destination where the permutation will be written to
</span><span class="cm">         * @param size size of weights and destination array
</span><span class="cm">         * @param rng random number generator
</span><span class="cm">         * @param sorter function to sort the permutation
</span><span class="cm">         */</span>
        <span class="kt">void</span> <span class="nf">monteCarloPermutation</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">weights</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">destination</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">RNG</span> <span class="o">&amp;</span><span class="n">rng</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">Sorter</span> <span class="o">&amp;</span><span class="n">sorter</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">draw</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">draw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">log2</span><span class="p">(</span><span class="n">rng</span><span class="p">())</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">destination</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">sorter</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/**
</span><span class="cm">         * Get the index of the first zero payout after which all payouts are zero as well
</span><span class="cm">         * @param payouts the payouts array
</span><span class="cm">         * @param size the size of the array
</span><span class="cm">         * @return the index of the first zero payout
</span><span class="cm">         */</span>
        <span class="kt">int</span> <span class="nf">firstZeroPayout</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">payouts</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">firstZeroPayout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">firstZeroPayout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">payouts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">firstZeroPayout</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">payouts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">firstZeroPayout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">firstZeroPayout</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/**
</span><span class="cm">         * Compute the mean of a batch of samples
</span><span class="cm">         * @param samples the samples
</span><span class="cm">         * @param nbPlayers the size of each sample aka the number of players
</span><span class="cm">         * @return a vector containing the mean of the samples
</span><span class="cm">         */</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">mean</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span> <span class="o">*&gt;</span> <span class="n">samples</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nbPlayers</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nbSamples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbSamples</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">double</span> <span class="o">*</span><span class="n">sample</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sample</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">nbSamples</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/**
</span><span class="cm">         * Compute the variance of samples
</span><span class="cm">         * @param samples the samples
</span><span class="cm">         * @param nbPlayers the size of each sample aka the number of players
</span><span class="cm">         * @return the variance
</span><span class="cm">         */</span>
        <span class="kt">double</span> <span class="nf">variance</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span> <span class="o">*&gt;</span> <span class="n">samples</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nbPlayers</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nbSamples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">meanSample</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">);</span>
            <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbSamples</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">double</span> <span class="o">*</span><span class="n">sample</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">double</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">meanSample</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// Not sure about nbSamples - 1, should be nbSamples but the paper about the stopping rule states n-1...
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">result</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">(</span><span class="n">nbSamples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/**
</span><span class="cm">         * Compute the threshold for the variance under which the stopping limit is considered reached
</span><span class="cm">         * @param alphaProbability confidence probability
</span><span class="cm">         * @param confidenceIntervalLength confidence interval length (root mean square)
</span><span class="cm">         * @param nbSamples number of samples
</span><span class="cm">         * @return the variance threshold
</span><span class="cm">         */</span>
        <span class="kt">double</span> <span class="nf">stoppingRuleLimit</span><span class="p">(</span><span class="kt">double</span> <span class="n">alphaProbability</span><span class="p">,</span> <span class="kt">double</span> <span class="n">confidenceIntervalLength</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nbSamples</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">zAlpha</span> <span class="o">=</span> <span class="n">NormalCDFInverse</span><span class="p">(</span><span class="n">alphaProbability</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alphaProbability</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// Symmetrical distribution
</span><span class="c1"></span>            <span class="k">return</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">nbSamples</span> <span class="o">*</span> <span class="n">confidenceIntervalLength</span> <span class="o">*</span> <span class="n">confidenceIntervalLength</span> <span class="o">/</span> <span class="n">zAlpha</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/**
</span><span class="cm">         * Pick the appropriate sorter depending on payouts. We can use a partial sort if most of the payouts are zero
</span><span class="cm">         * @param payouts the payouts
</span><span class="cm">         * @param nbPlayers the size of the payouts array aka the number of players
</span><span class="cm">         * @return a sorter
</span><span class="cm">         */</span>
        <span class="n">Sorter</span> <span class="nf">chooseSorter</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">payouts</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbPlayers</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Partial sort vs sort : interesting only if we have many zero payouts at the end
</span><span class="c1"></span>            <span class="k">const</span> <span class="kt">int</span> <span class="n">relevantRanksCount</span> <span class="o">=</span> <span class="n">firstZeroPayout</span><span class="p">(</span><span class="n">payouts</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">);</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="n">partialSortThreshold</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="c1">// Magic number &lt;3
</span><span class="c1"></span>            <span class="k">const</span> <span class="kt">bool</span> <span class="n">partialSort</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">relevantRanksCount</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">nbPlayers</span> <span class="o">&lt;=</span> <span class="n">partialSortThreshold</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">partialSort</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">draw</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">destination</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">partial_sort</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">destination</span> <span class="o">+</span> <span class="n">relevantRanksCount</span><span class="p">,</span> <span class="n">destination</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
                                 <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                                     <span class="c1">// Reverse order
</span><span class="c1"></span>                                     <span class="k">return</span> <span class="p">(</span><span class="n">draw</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">draw</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
                                 <span class="p">}</span>
                    <span class="p">);</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="p">[](</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">draw</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">destination</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sort</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">destination</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
                     <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                         <span class="c1">// Reverse order
</span><span class="c1"></span>                         <span class="k">return</span> <span class="p">(</span><span class="n">draw</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">draw</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
                     <span class="p">});</span>
            <span class="p">};</span>
        <span class="p">}</span>

        <span class="cm">/**
</span><span class="cm">         * Create a RNG instance (using SFMT)
</span><span class="cm">         * @return a RNG instance
</span><span class="cm">         */</span>
        <span class="n">RNG</span> <span class="nf">defaultRng</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// Initialize random distribution
</span><span class="c1"></span>            <span class="c1">// https://stackoverflow.com/questions/19665818/generate-random-numbers-using-c11-random-library
</span><span class="c1"></span>            <span class="c1">// SFMT variant
</span><span class="c1"></span>            <span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
            <span class="n">wtl</span><span class="o">::</span><span class="n">sfmt19937</span> <span class="n">mt</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
            <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wtl</span><span class="o">::</span><span class="n">sfmt19937</span><span class="o">&gt;</span> <span class="n">mtPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wtl</span><span class="o">::</span><span class="n">sfmt19937</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mt</span><span class="p">);</span>
            <span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mtPtr</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wtl</span><span class="o">::</span><span class="n">sfmt19937</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mt</span><span class="p">),</span>
                    <span class="n">distPtr</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">dist</span><span class="p">)]()</span> <span class="o">-&gt;</span> <span class="kt">double</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">distPtr</span><span class="p">)((</span><span class="o">*</span><span class="n">mtPtr</span><span class="p">));</span>
            <span class="p">};</span>
        <span class="p">}</span>

        <span class="cm">/**
</span><span class="cm">         * Check if we can stop the trials according to the confidence probability and interval
</span><span class="cm">         * @param alphaProbability the confidence probability
</span><span class="cm">         * @param confidenceIntervalLength confidence interval length (root mean square)
</span><span class="cm">         * @param samples the samples
</span><span class="cm">         * @param nbPlayers the number of players
</span><span class="cm">         * @return true if the stopping rule criteria are met
</span><span class="cm">         */</span>
        <span class="kt">bool</span> <span class="nf">canStop</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">alphaProbability</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">confidenceIntervalLength</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span> <span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">samples</span><span class="p">,</span>
                     <span class="k">const</span> <span class="kt">int</span> <span class="n">nbPlayers</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nbSamples</span> <span class="o">=</span> <span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nbSamples</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">double</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">stoppingRuleLimit</span><span class="p">(</span><span class="n">alphaProbability</span><span class="p">,</span> <span class="n">confidenceIntervalLength</span><span class="p">,</span> <span class="n">nbSamples</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">variance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/**
</span><span class="cm">         * Normalize stacks (not really necessary but cheap) and invert to weights
</span><span class="cm">         * @param stacks the stacks
</span><span class="cm">         * @param nbPlayers the number of players
</span><span class="cm">         * @param weights the destination array
</span><span class="cm">         */</span>
        <span class="kt">void</span> <span class="nf">fillWeights</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">stacks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">weights</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="n">stacksAvg</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">stacks</span><span class="p">,</span> <span class="n">stacks</span> <span class="o">+</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">nbPlayers</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stacksAvg</span> <span class="o">/</span> <span class="n">stacks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * Perform one MC trial
</span><span class="cm">     *
</span><span class="cm">     * @param results destination array to add trial contribution into
</span><span class="cm">     * @param payouts the contribution to add to the results per rank
</span><span class="cm">     * @param weights something proportional to the inverse of the stacks of the players
</span><span class="cm">     * @param permutation an array that will be used to store the permutation (permutation[i] = player that reaches rank i)
</span><span class="cm">     * @param nbPlayers the number of players
</span><span class="cm">     * @param rng random number generator
</span><span class="cm">     * @param sorter function to sort the permutation
</span><span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">monteCarloIcmTrial</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">results</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">payouts</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">weights</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">permutation</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbPlayers</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">RNG</span> <span class="o">&amp;</span><span class="n">rng</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sorter</span> <span class="o">&amp;</span><span class="n">sorter</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">monteCarloPermutation</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">permutation</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">sorter</span><span class="p">);</span>
        <span class="c1">// Cumulate payouts according to the random permutation
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">results</span><span class="p">[</span><span class="n">permutation</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">payouts</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * Monte-Carlo ICM Ranking algorithm.
</span><span class="cm">     *
</span><span class="cm">     * @param stacks the stacks
</span><span class="cm">     * @param payouts the payouts
</span><span class="cm">     * @param nbPlayers the number of players
</span><span class="cm">     * @param trials the number of trials to perform
</span><span class="cm">     * @param results destination array for ICM EV
</span><span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">monteCarloIcm</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">stacks</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">payouts</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">trials</span><span class="p">,</span>
                       <span class="kt">double</span> <span class="o">*</span><span class="n">results</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Algorithm : https://forumserver.twoplustwo.com/15/poker-theory/new-algorithm-calculate-icm-large-tournaments-1098489/
</span><span class="c1"></span>        <span class="n">RNG</span> <span class="n">rng</span> <span class="o">=</span> <span class="n">defaultRng</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">permutation</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>

        <span class="kt">double</span> <span class="n">weights</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>
        <span class="n">fillWeights</span><span class="p">(</span><span class="n">stacks</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="n">weights</span><span class="p">);</span>

        <span class="kt">double</span> <span class="n">contrib</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>
        <span class="c1">// Prepare each trial ranking contribution to the total
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">contrib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">payouts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">trials</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">const</span> <span class="n">Sorter</span> <span class="n">sorter</span> <span class="o">=</span> <span class="n">chooseSorter</span><span class="p">(</span><span class="n">payouts</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">trials</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">monteCarloIcmTrial</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">contrib</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">permutation</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">sorter</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * Monte-Carlo ICM Ranking algorithm with stopping rule.
</span><span class="cm">     *
</span><span class="cm">     * @param stacks the stacks
</span><span class="cm">     * @param payouts the payouts
</span><span class="cm">     * @param nbPlayers the number of players
</span><span class="cm">     * @param results destination array for ICM EV
</span><span class="cm">     * @param stoppingAlphaProbability the confidence probability
</span><span class="cm">     * @param stoppingConfidenceIntervalLength confidence interval length (root mean square)
</span><span class="cm">     * @param stoppingEvalLag the number of trials that are performed before each evaluation of the stopping rule
</span><span class="cm">     */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="nf">monteCarloIcmWithStoppingRule</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">stacks</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">payouts</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nbPlayers</span><span class="p">,</span>
                                            <span class="kt">double</span> <span class="o">*</span><span class="n">results</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">stoppingAlphaProbability</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">double</span> <span class="n">stoppingConfidenceIntervalLength</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">stoppingEvalLag</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Algorithm : https://forumserver.twoplustwo.com/15/poker-theory/new-algorithm-calculate-icm-large-tournaments-1098489/
</span><span class="c1"></span>        <span class="c1">// Stopping rule : http://www.lib.ncsu.edu/resolver/1840.4/5244 (first method for independent samples)
</span><span class="c1"></span>        <span class="n">RNG</span> <span class="n">rng</span> <span class="o">=</span> <span class="n">defaultRng</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">permutation</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>

        <span class="kt">double</span> <span class="n">weights</span><span class="p">[</span><span class="n">nbPlayers</span><span class="p">];</span>
        <span class="n">fillWeights</span><span class="p">(</span><span class="n">stacks</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="n">weights</span><span class="p">);</span>

        <span class="c1">// For each trial we&#39;ll contribute the real payouts because we want to use them for the stopping rule
</span><span class="c1"></span>        <span class="c1">// computation
</span><span class="c1"></span>
        <span class="k">const</span> <span class="n">Sorter</span> <span class="n">sorter</span> <span class="o">=</span> <span class="n">chooseSorter</span><span class="p">(</span><span class="n">payouts</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">);</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span> <span class="o">*&gt;</span> <span class="n">samples</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span> <span class="o">*&gt;</span> <span class="n">allocated</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// While we don&#39;t stop according to the stopping rule, we create a batch of samples
</span><span class="c1"></span>            <span class="k">auto</span> <span class="o">*</span><span class="n">memory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="n">nbPlayers</span> <span class="o">*</span> <span class="n">stoppingEvalLag</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
            <span class="c1">// Store the allocated memory area pointer
</span><span class="c1"></span>            <span class="n">allocated</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stoppingEvalLag</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">double</span> <span class="o">*</span><span class="n">sampleMemory</span> <span class="o">=</span> <span class="n">memory</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">nbPlayers</span><span class="p">;</span>
                <span class="n">monteCarloIcmTrial</span><span class="p">(</span><span class="n">sampleMemory</span><span class="p">,</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">double</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">payouts</span><span class="p">),</span> <span class="n">weights</span><span class="p">,</span> <span class="n">permutation</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span>
                                   <span class="n">sorter</span><span class="p">);</span>
                <span class="c1">// Store the pointer to the sample
</span><span class="c1"></span>                <span class="n">samples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sampleMemory</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">stoppingEvalLag</span><span class="p">;</span>
            <span class="c1">// Break if the stopping rule says it&#39;s enough
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">canStop</span><span class="p">(</span><span class="n">stoppingAlphaProbability</span><span class="p">,</span> <span class="n">stoppingConfidenceIntervalLength</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// Sum the samples
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="nl">sample</span> <span class="p">:</span> <span class="n">samples</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// Divide the sum to get the mean
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbPlayers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Free the allocated memory areas
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="nl">memory</span> <span class="p">:</span> <span class="n">allocated</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">free</span><span class="p">(</span><span class="n">memory</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// Return the number of samples that were generated
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>monte-carlo-icm.hpp</code>
<em>Déclarez les fonctions qu&rsquo;il vous intéresse d&rsquo;exposer !</em></p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>A Brief Survey of Stopping Rules in Monte Carlo Simulations, 1968, Gilman - <a href="https://repository.lib.ncsu.edu/handle/1840.4/5244" target="_blank" rel="noopener">https://repository.lib.ncsu.edu/handle/1840.4/5244</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" class="icon footnote-icon"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 329.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg></a></p>
</li>
</ol>
</section>

            </div>

            
    
    
        <ul class="post-copyright">
            <li class="copyright-item author"><span class="copyright-item-text">Auteur</span> : <a href="https://pittscraft.com/about/" class="p-author h-card" target="_blank" rel="noopener">Pitt</a></li>
            
                
                
                
                
                <li class="copyright-item link"><span class="copyright-item-text">Lien</span> : <a href="/posts/poker_mtt_icm_monte_carlo/" target="_blank" rel="noopener">https://pittscraft.com/posts/poker_mtt_icm_monte_carlo/</a></li>
            
            
        </ul>
    



        </article>

        

        
    <div class="updated-badge-container">
        <span title="Updated @ 2021-03-31 08:14:35 &#43;0100" style="cursor:help">

<svg xmlns="http://www.w3.org/2000/svg" width="130" height="20" class="updated-badge"><linearGradient id="b" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="a"><rect width="130" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#a)"><path class="updated-badge-left" d="M0 0h55v20H0z"/><path class="updated-badge-right" d="M55 0h75v20H55z"/><path fill="url(#b)" d="M0 0h130v20H0z"/></g><g fill="#fff" text-anchor="middle" font-size="110"><text x="285" y="150" fill="#010101" fill-opacity=".3" textLength="450" transform="scale(.1)">updated</text><text x="285" y="140" textLength="450" transform="scale(.1)">updated</text><text x="915" y="150" fill="#010101" fill-opacity=".3" textLength="650" transform="scale(.1)">2021-03-31</text><text x="915" y="140" textLength="650" transform="scale(.1)">2021-03-31</text></g></svg>
        </span></div>



        


        <div class="post-share">

        

        <div class="share-items">

            
                <div class="share-item twitter">
                    
                    <a href="https://twitter.com/share?url=https://pittscraft.com/posts/poker_mtt_icm_monte_carlo/&amp;text=Poker%20:%20MTT%20et%20ICM%20-%20M%c3%a9thode%20de%20Monte-Carlo&amp;hashtags=Poker,AI,ICM,MTT,GameTheory,MonteCarlo,&amp;via=Pitt51279043" title="Partage sur Twitter" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon twitter-icon"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></a>
                </div>
            

            
                <div class="share-item facebook">
                    
                    <a href="https://www.facebook.com/sharer/sharer.php?u=https://pittscraft.com/posts/poker_mtt_icm_monte_carlo/&amp;hashtag=%23Poker" title="Partage sur Facebook" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon facebook-icon"><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg></a>
                </div>
            

            
                <div class="share-item linkedin">
                    
                    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://pittscraft.com/posts/poker_mtt_icm_monte_carlo/&amp;title=Poker%20:%20MTT%20et%20ICM%20-%20M%c3%a9thode%20de%20Monte-Carlo&amp;summary=Un%20Monaco-Picon%20s%27il%20vous%20pla%c3%aet.%20En%20pinte.&amp;source=Pitt%27s%20Craft" title="Partage sur LinkedIn" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon linkedin-icon"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg></a>
                </div>
            

            
                <div class="share-item telegram">
                    
                    <a href="https://t.me/share/url?url=https://pittscraft.com/posts/poker_mtt_icm_monte_carlo/&amp;text=Poker%20:%20MTT%20et%20ICM%20-%20M%c3%a9thode%20de%20Monte-Carlo" title="Partage sur Telegram" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon telegram-icon"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9l-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"/></svg></a>
                </div>
            

            

            

            

            

            

        </div>

    </div>




        
    
    
        <div class="related-posts">
            <h2 class="related-title">Lire aussi : <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon related-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"/></svg></h2>
            <ul class="related-list">
                
                    <li class="related-item">
                        <a href="/posts/poker_mtt_icm_deep_learning/" class="related-link">Poker : MTT et ICM - Perf Tuning avec du Deep Learning</a>
                    </li>
                
                    <li class="related-item">
                        <a href="/posts/poker_mtt_icm_calcul/" class="related-link">Poker : MTT et ICM - Le Calcul Brutal</a>
                    </li>
                
                    <li class="related-item">
                        <a href="/posts/poker_mtt_icm_question/" class="related-link">Poker : MTT et ICM - La Question</a>
                    </li>
                
            </ul>
        </div>
    



        
    
        <div class="post-tags">
            
                
                
                
                
                    
                    <a href="/tags/poker/" rel="tag" class="post-tags-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>Poker</a>
                
            
                
                
                
                
                    
                    <a href="/tags/ai/" rel="tag" class="post-tags-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>AI</a>
                
            
                
                
                
                
                    
                    <a href="/tags/icm/" rel="tag" class="post-tags-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>ICM</a>
                
            
                
                
                
                
                    
                    <a href="/tags/mtt/" rel="tag" class="post-tags-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>MTT</a>
                
            
                
                
                
                
                    
                    <a href="/tags/game-theory/" rel="tag" class="post-tags-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>Game Theory</a>
                
            
                
                
                
                
                    
                    <a href="/tags/monte-carlo/" rel="tag" class="post-tags-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tag-icon"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"/></svg>Monte Carlo</a>
                
            
        </div>
    



        


        


        
    
        
        
    
    
    
    
        <ul class="post-nav">
            
                <li class="post-nav-prev">
                    <a href="/posts/poker_mtt_icm_deep_learning/" rel="prev">&lt; Poker : MTT et ICM - Perf Tuning avec du Deep Learning</a>
                </li>
            
            
                <li class="post-nav-next">
                    <a href="/posts/poker_mtt_icm_calcul/" rel="next">Poker : MTT et ICM - Le Calcul Brutal &gt;</a>
                </li>
            
        </ul>
    



        


    </div>
</main>


            
    <div id="back-to-top" class="back-to-top">
        <a href="#"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a>
    </div>


            
    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="site-info">©&nbsp;2020–2021&nbsp;Pitt</div><div class="site-copyright"></div><div class="custom-footer">Little Pouillé EURL</div>

            
    
        <ul class="socials"><li class="socials-item">
                    <a href="/rss.xml" target="_blank" rel="external noopener" title="RSS"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon social-icon"><path d="M19.199 24C19.199 13.467 10.533 4.8 0 4.8V0c13.165 0 24 10.835 24 24h-4.801zM3.291 17.415c1.814 0 3.293 1.479 3.293 3.295 0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526 0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727 0 15.909 7.184 15.909 15.91z"/></svg></a>
                </li><li class="socials-item">
                    <a href="mailto:pitt@pittscraft.com" target="_blank" rel="external noopener" title="Email"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon social-icon"><path d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"/></svg></a>
                </li><li class="socials-item">
                    <a href="https://github.com/PittsCraft" target="_blank" rel="external noopener" title="GitHub"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon social-icon"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a>
                </li></ul>
    



            
        </div>
    </footer>


        </div>
        

        








    <script src="https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js"></script>

<script>
    mediumZoom(document.querySelectorAll('div.post-body img'), {
        background: 'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'
    })
</script>









    </body>
</html>
